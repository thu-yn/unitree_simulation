/**********************************************************************
Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/**
* @file ControlFrame.cpp  
* @brief 四足机器人主控制框架实现
* 
* 文件作用：
* 该文件实现了ControlFrame类，是整个控制系统的最顶层框架，负责协调和管理
* 四足机器人的全部控制逻辑。它是连接底层硬件接口和上层控制算法的重要桥梁。
* 
* 主要功能：
* 1. 🎯 控制协调中心 - 作为整个控制系统的入口和协调器
* 2. 🤖 状态机管理 - 封装和管理FSM（有限状态机）控制器
* 3. 🔄 控制循环执行 - 提供500Hz高频控制循环的顶层接口
* 4. 💾 资源生命周期管理 - 负责控制相关资源的创建和销毁
* 
* 在整个控制系统中的作用：
* ControlFrame是控制系统的"总指挥官"，它位于系统架构的最顶层：
* 
* 系统层次结构：
* main()                    <- 程序入口，负责系统初始化
*   ↓
* ControlFrame              <- 📍 当前文件：控制框架总协调器
*   ↓
* FSM (有限状态机)           <- 决策层：根据当前状态和输入决定行为
*   ↓
* FSMState (具体状态)        <- 执行层：实现具体的控制行为
*   ↓
* CtrlComponents            <- 组件层：提供控制所需的各种功能组件
*   ↓
* IOInterface               <- 接口层：与硬件或仿真环境通信
* 
* 设计理念：
* - 🎯 单一职责：仅负责控制框架的顶层协调，不涉及具体控制算法
* - 🔄 委托模式：将具体的控制决策委托给FSM状态机处理
* - 💡 简洁设计：保持接口简洁，易于理解和维护
* - ⚡ 高效执行：最小化顶层开销，确保实时性要求
* 
* 工作流程：
* 1. 构造时创建FSM状态机控制器
* 2. 每个控制周期调用run()方法
* 3. run()方法直接委托给FSM执行具体的控制逻辑
* 4. 析构时清理FSM控制器资源
* 
* 该文件虽然代码量少，但在架构上起到关键的"桥接"作用，是理解整个
* 控制系统架构的重要入口点。
*/

#include "control/ControlFrame.h"

/**
* @brief ControlFrame构造函数
* @param ctrlComp 控制组件集合指针，包含控制系统所需的所有组件
* 
* 构造函数的主要职责：
* 1. 保存控制组件的引用，建立与底层系统的连接
* 2. 创建FSM（有限状态机）控制器，这是控制系统的核心决策模块
* 3. 将控制组件传递给FSM，让状态机能够访问所有必要的控制资源
* 
* 参数说明：
* ctrlComp包含了控制系统运行所需的所有组件，包括：
* - lowCmd: 底层控制命令（发送给机器人的指令）
* - lowState: 底层状态反馈（从机器人接收的状态）
* - ioInter: IO接口（与硬件或仿真环境的通信接口）
* - robotModel: 机器人模型（运动学和动力学参数）
* - waveGen: 波形生成器（步态生成）
* - estimator: 状态估计器（传感器数据融合）
* - balCtrl: 平衡控制器（力分配和平衡控制）
* - contact: 足端接触状态
* - phase: 步态相位信息
* - dt: 控制周期（通常为0.002s，对应500Hz）
* 
* 设计考虑：
* - 使用初始化列表提高效率，避免不必要的拷贝构造
* - 采用指针传递，避免大对象的复制开销
* - FSM控制器在堆上创建，便于多态和动态管理
*/
ControlFrame::ControlFrame(CtrlComponents *ctrlComp) 
    : _ctrlComp(ctrlComp) {  // 使用初始化列表保存控制组件引用
    
    /**
    * 创建FSM（有限状态机）控制器
    * 
    * FSM是控制系统的核心决策模块，负责：
    * 1. 管理机器人的各种行为状态（被动、站立、行走等）
    * 2. 根据用户输入和系统状态进行状态转换
    * 3. 在每个控制周期执行当前状态对应的控制逻辑
    * 4. 处理异常情况和安全保护
    * 
    * FSM的主要状态包括：
    * - PASSIVE: 被动状态（机器人躺下，关节松弛）
    * - FIXEDSTAND: 固定站立（关节锁定在初始位置）
    * - FREESTAND: 自由站立（启用平衡控制但不移动）
    * - TROTTING: 小跑步态（正常行走运动）
    * - BALANCETEST: 平衡测试（测试平衡控制性能）
    * - SWINGTEST: 摆动测试（测试单腿运动）
    * - STEPTEST: 步伐测试（测试步态生成）
    * 
    * 将ctrlComp传递给FSM，使状态机能够访问：
    * - 传感器数据（通过lowState）
    * - 控制输出（通过lowCmd）
    * - 控制算法（通过estimator、balCtrl等）
    * - 用户输入（通过ioInter）
    */
    _FSMController = new FSM(_ctrlComp);
}

/**
* @brief 控制框架主运行函数
* 
* 这是控制框架的核心方法，在每个控制周期（通常500Hz）被调用一次。
* 该方法体现了"委托"设计模式的精髓：将具体的控制逻辑完全委托给
* FSM状态机处理，自身只负责顶层的调用协调。
* 
* 执行流程：
* 1. 被main()函数中的控制循环定期调用（500Hz）
* 2. 直接调用FSM控制器的run()方法
* 3. FSM根据当前状态执行相应的控制逻辑
* 4. 返回到main()函数，准备下一个控制周期
* 
* FSM的run()方法内部会执行以下流程：
* 1. 检查状态转换条件，判断是否需要切换状态
* 2. 执行当前状态的控制逻辑（currentState->run()）
* 3. 处理用户输入和系统事件
* 4. 更新控制输出和状态信息
* 5. 执行安全检查和异常处理
* 
* 设计优势：
* - 🎯 职责清晰：顶层框架只负责调度，不涉及具体逻辑
* - 🔄 层次分明：保持清晰的架构层次，便于理解和维护
* - ⚡ 执行高效：最小化顶层开销，大部分时间消耗在实际控制算法上
* - 🔧 易于扩展：新增功能只需在FSM和状态层面实现，不影响顶层框架
* 
* 调用关系：
* main() -> ControlFrame::run() -> FSM::run() -> currentState->run()
*                                              -> 具体控制算法执行
*/
void ControlFrame::run() {
    /**
    * 委托FSM执行具体的控制逻辑
    * 
    * 这里体现了良好的软件设计原则：
    * - 单一职责原则：ControlFrame只负责顶层协调
    * - 开闭原则：通过FSM的多态性支持功能扩展
    * - 依赖倒置原则：依赖FSM抽象而非具体实现
    * 
    * _FSMController->run()的执行过程：
    * 1. 检查和处理状态转换
    * 2. 执行当前状态的控制逻辑
    * 3. 更新系统状态和输出命令
    * 4. 处理异常和安全保护
    */
    _FSMController->run();
}

/**
* 总结：ControlFrame类的设计哲学
* 
* ControlFrame虽然代码简洁，但在整个控制系统中起到关键作用：
* 
* 1. 📐 架构层面：
*    - 提供清晰的控制系统入口点
*    - 建立合理的软件分层架构
*    - 实现顶层控制逻辑的封装
* 
* 2. 🎯 设计层面：
*    - 采用委托模式，职责分离明确
*    - 最小化接口，保持简洁易用
*    - 通过FSM实现复杂控制逻辑的管理
* 
* 3. 🔧 实现层面：
*    - 资源管理清晰（构造时创建，析构时销毁）
*    - 执行效率高（直接委托，无额外开销）
*    - 易于调试和维护
* 
* 4. 🔄 运行层面：
*    - 作为控制循环的统一入口
*    - 确保实时性要求（500Hz控制频率）
*    - 提供稳定可靠的控制框架
* 
* 该类是理解整个unitree_guide控制系统的重要起点，展示了如何通过
* 简洁的顶层设计来管理复杂的机器人控制系统。它的价值不在于代码的
* 复杂度，而在于为整个系统提供了清晰的架构基础和统一的控制入口。
* 
* 学习建议：
* - 理解该类在整个系统架构中的位置和作用
* - 掌握委托设计模式在控制系统中的应用
* - 关注如何通过简洁的接口管理复杂的系统
* - 学习实时控制系统的顶层设计思路
*/