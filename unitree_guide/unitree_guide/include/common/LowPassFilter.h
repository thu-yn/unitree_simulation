/**********************************************************************
 Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/**
 * @file LowPassFilter.h
 * @brief 低通滤波器实现库
 * 
 * 【文件作用总览】
 * 本文件实现了一个简单高效的低通滤波器类，是机器人控制系统中重要的信号处理组件。
 * 主要功能包括：
 * 
 * 1. **信号平滑处理**：对传感器数据进行实时滤波，去除高频噪声
 * 2. **数值稳定性**：采用指数加权移动平均算法，数值计算稳定
 * 3. **实时性能**：计算复杂度低，适合高频控制循环使用
 * 4. **参数直观**：通过截止频率直接控制滤波强度
 * 
 * 【应用场景】
 * - IMU传感器数据滤波（加速度、角速度、姿态角）
 * - 关节位置和速度反馈信号处理
 * - 力传感器和扭矩传感器数据平滑
 * - 控制指令的平滑输出
 * - 状态估计中的观测值预处理
 * 
 * 【技术特点】
 * - 内存占用极小，只需存储一个历史值
 * - 参数设置简单，适合工程应用
 * - 支持运行时状态重置，便于系统重新初始化
 * - 相位延迟小，适合实时控制应用
 */

#ifndef LOWPASSFILTER
#define LOWPASSFILTER

/**
 * @brief 低通滤波器类
 * 
 * 该类实现了一个简单而高效的低通滤波器，主要用于对传感器数据进行平滑处理，
 * 去除高频噪声。低通滤波器在机器人控制系统中广泛应用，特别是在处理
 * IMU数据、关节位置反馈、力传感器数据等方面。
 * 
 * 工作原理：
 * 采用指数加权移动平均(Exponential Weighted Moving Average, EWMA)算法，
 * 新的输出值 = 权重 × 新输入值 + (1 - 权重) × 前一个输出值
 * 
 * 其中权重的计算公式为：
 * weight = 1 / (1 + 1/(2π × 采样周期 × 截止频率))
 * 
 * 特点：
 * - 计算简单，实时性好
 * - 内存占用小，只需保存一个历史值
 * - 参数调节直观，通过截止频率控制滤波强度
 */
class LPFilter{
public:
    /**
     * @brief 构造函数 - 初始化低通滤波器
     * 
     * @param samplePeriod 采样周期 (单位：秒)
     *                     表示两次相邻采样之间的时间间隔
     *                     例如：如果控制频率是1000Hz，则采样周期为0.001秒
     * 
     * @param cutFrequency 截止频率 (单位：Hz)
     *                     表示滤波器的3dB截止频率，超过此频率的信号将被显著衰减
     *                     截止频率越低，滤波效果越强，但会增加相位延迟
     *                     常用值：
     *                     - 对于位置信号：5-20 Hz
     *                     - 对于速度信号：10-50 Hz
     *                     - 对于加速度信号：20-100 Hz
     * 
     * 构造函数中会根据给定参数自动计算滤波器权重：
     * _weight = 1.0 / (1.0 + 1.0/(2.0*M_PI * samplePeriod * cutFrequency))
     * 
     * 该公式来源于将连续时间域的低通滤波器离散化的结果
     */
    LPFilter(double samplePeriod, double cutFrequency);
    
    /**
     * @brief 析构函数 - 释放资源
     * 
     * 由于该类没有动态分配内存，析构函数为默认实现
     */
    ~LPFilter();
    
    /**
     * @brief 添加新的输入值并更新滤波器状态
     * 
     * @param newValue 新的输入值
     *                 可以是任何需要滤波的数值信号，如：
     *                 - 传感器读数
     *                 - 关节角度
     *                 - 速度反馈
     *                 - 力/扭矩测量值
     * 
     * 该函数执行滤波算法的核心计算：
     * 1. 如果是第一次输入，直接将输入值作为输出值
     * 2. 否则，使用EWMA算法更新输出：
     *    新输出 = _weight * newValue + (1 - _weight) * 旧输出
     * 
     * 注意：该函数会修改滤波器的内部状态，每次调用都会产生新的滤波结果
     */
    void addValue(double newValue);
    
    /**
     * @brief 获取当前滤波器的输出值
     * 
     * @return double 当前的滤波输出值
     * 
     * 返回值特性：
     * - 第一次添加数据后，返回值等于第一个输入值
     * - 后续返回值是历史输入的加权平均结果
     * - 输出值的变化相对于输入值有一定的延迟（相位延迟）
     * 
     * 使用场景：
     * - 获取平滑后的传感器数据用于控制计算
     * - 实时监控滤波效果
     * - 数据记录和分析
     */
    double getValue();
    
    /**
     * @brief 清除滤波器状态，重置为初始状态
     * 
     * 该函数会：
     * 1. 将 _start 标志重置为 false
     * 2. 下次调用 addValue() 时，输入值将被直接用作输出值
     * 
     * 使用场景：
     * - 系统重启或模式切换时
     * - 检测到传感器异常需要重新初始化时
     * - 测试期间需要重置滤波器状态时
     * 
     * 注意：清除后的第一个输入值不会被滤波，直接作为输出
     */
    void clear();
    
private:
    /**
     * @brief 滤波器权重系数
     * 
     * 范围：(0, 1)
     * - 接近0：滤波效果强，输出变化缓慢，延迟大
     * - 接近1：滤波效果弱，输出快速跟踪输入，延迟小
     * 
     * 该值在构造函数中根据采样周期和截止频率计算得出
     */
    double _weight;
    
    /**
     * @brief 上一次的滤波输出值
     * 
     * 存储前一时刻的滤波器输出，用于下一次滤波计算
     * 这是EWMA算法的核心：新输出依赖于历史输出
     */
    double _pastValue;
    
    /**
     * @brief 启动标志
     * 
     * - false：滤波器尚未接收到任何输入
     * - true：滤波器已经开始工作
     * 
     * 该标志用于处理第一个输入值的特殊情况：
     * 第一个输入值直接作为输出，避免初始化偏差
     */
    bool _start;
};

#endif  // LOWPASSFILTER