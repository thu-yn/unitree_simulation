/**********************************************************************
 Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/
#ifndef ENUMCLASS_H
#define ENUMCLASS_H

#include <iostream>
#include <sstream>

/**
 * @file enumClass.h
 * @brief 四足机器人控制系统的核心枚举类型定义
 * 
 * 本文件定义了整个机器人控制系统中使用的所有重要枚举类型。
 * 这些枚举类型统一了系统中的类型定义，提高了代码的可读性和可维护性。
 * 
 * 设计理念：
 * - 类型安全：使用enum class避免隐式类型转换
 * - 语义明确：每个枚举值都有明确的含义和用途
 * - 扩展性好：便于添加新的类型值和新的枚举类型
 * - 调试友好：枚举名直接反映其含义，便于调试
 * 
 * 覆盖范围：
 * - 硬件平台类型：仿真环境 vs 真实机器人
 * - 机器人型号：A1, Go1等不同型号的区分
 * - 用户指令：遥控器按键到系统命令的映射
 * - 坐标系类型：不同参考坐标系的定义
 * - 状态机：控制状态和模式的定义
 * - 步态相关：步态阶段和模式的定义
 */

/**
 * @brief 控制平台枚举类型
 * 
 * 区分程序运行的硬件平台类型，决定了：
 * - 使用的通信接口类型（ROS话题 vs SDK直接通信）
 * - 控制参数的设置（仿真和真实环境的参数差异）
 * - 安全检查的严格程度（真实机器人需要更多安全措施）
 * - 传感器数据的处理方式
 * 
 * 平台选择通常在编译时通过宏定义确定：
 * - COMPILE_WITH_SIMULATION → GAZEBO
 * - COMPILE_WITH_REAL_ROBOT → REALROBOT
 */
enum class CtrlPlatform{
    /**
     * @brief Gazebo仿真平台
     * 
     * 特点：
     * - 通过ROS话题与Gazebo物理仿真器通信
     * - 使用IOROS接口类进行数据交换
     * - 物理参数可能与真实机器人略有差异
     * - 支持完美的传感器数据（无噪声、无延迟）
     * - 可以进行危险动作测试而无安全风险
     * 
     * 应用场景：
     * - 算法开发和验证
     * - 参数调优
     * - 安全性测试
     * - 教学演示
     */
    GAZEBO,
    
    /**
     * @brief 真实机器人平台
     * 
     * 特点：
     * - 通过Unitree SDK与机器人硬件直接通信
     * - 使用IOSDK接口类进行数据交换
     * - 需要考虑真实的物理约束和限制
     * - 传感器数据包含噪声和延迟
     * - 需要严格的安全检查和限制
     * 
     * 应用场景：
     * - 实际产品部署
     * - 真实环境测试
     * - 性能评估
     * - 商业应用
     */
    REALROBOT,
};

/**
 * @brief 机器人型号枚举类型
 * 
 * 区分不同型号的Unitree机器人，每个型号有不同的：
 * - 物理参数（质量、尺寸、惯性）
 * - 关节限制（角度范围、速度范围、力矩范围）
 * - 运动性能（最大速度、负载能力）
 * - 硬件配置（传感器类型、计算能力）
 * 
 * 型号选择通常在编译时通过宏定义确定：
 * - ROBOT_TYPE_A1 → A1
 * - ROBOT_TYPE_Go1 → Go1
 */
enum class RobotType{
    /**
     * @brief A1机器人
     * 
     * Unitree A1是第一代商用四足机器人：
     * - 重量：~12.5kg（真机）/ ~13.4kg（仿真）
     * - 尺寸：较大，适合科研和教育
     * - 性能：稳定可靠，负载能力强
     * - 成本：相对较高，主要面向B端用户
     * 
     * 几何参数：
     * - 机体长度：0.361m（前后髋关节距离）
     * - 机体宽度：0.094m（左右髋关节距离）
     * - 腿部链长：髋关节0.0838m，大腿0.2m，小腿0.2m
     */
    A1,
    
    /**
     * @brief Go1机器人
     * 
     * Unitree Go1是改进型四足机器人：
     * - 重量：~10.5kg（真机）/ ~12.0kg（仿真）  
     * - 尺寸：更紧凑，便于携带和部署
     * - 性能：更高的机动性和运动灵活性
     * - 成本：更适合大规模商业应用
     * 
     * 几何参数：
     * - 机体长度：0.376m（前后髋关节距离）
     * - 机体宽度：0.0935m（左右髋关节距离）
     * - 腿部链长：髋关节0.08m，大腿0.213m，小腿0.213m
     */
    Go1
};

/**
 * @brief 用户指令枚举类型
 * 
 * 将用户的物理输入（遥控器按键、键盘按键）映射为系统内部的标准指令。
 * 这种抽象层使得系统可以支持多种输入设备，而不需要修改核心控制逻辑。
 * 
 * 指令来源：
 * - 遥控器按键：通过ROS话题接收遥控器数据
 * - 键盘输入：通过KeyBoard类处理键盘事件
 * - 程序化命令：通过编程接口直接发送
 * 
 * 指令处理流程：
 * 1. 物理输入设备产生信号
 * 2. IOInterface接收并解析信号
 * 3. 转换为UserCommand枚举值
 * 4. FSMState::checkChange()根据命令决定状态转换
 */
enum class UserCommand{
    /**
     * @brief 无命令状态
     * 默认状态，表示没有用户输入或输入已处理完毕
     */
    // EXIT,      // 未使用，可能用于退出程序
    NONE,

    /**
     * @brief 开始小跑指令
     * 
     * 触发方式：
     * - 遥控器：通常对应START按键或特定按键组合
     * - 键盘：'4'键（在某些配置中）
     * 
     * 功能：让机器人进入动态行走状态
     * 目标状态：FSMStateName::TROTTING
     * 
     * 安全要求：
     * - 机器人必须已经处于站立状态
     * - 电池电量充足
     * - 无严重传感器故障
     */
    START,      // trotting

    /**
     * @brief 固定站立指令
     * 
     * 触发方式：
     * - 遥控器：L2+A按键组合
     * - 键盘：'2'键
     * 
     * 功能：让机器人进入固定位置的站立状态
     * 目标状态：FSMStateName::FIXEDSTAND
     * 
     * 特点：
     * - 机器人保持固定的关节角度
     * - 足端位置保持在理想站立位置
     * - 具有一定的抗干扰能力
     * - 为动态运动做准备
     */
    L2_A,       // fixedStand

    /**
     * @brief 被动状态指令
     * 
     * 触发方式：
     * - 遥控器：L2+B按键组合
     * - 键盘：ESC键或特定安全按键
     * 
     * 功能：让机器人进入完全被动状态
     * 目标状态：FSMStateName::PASSIVE
     * 
     * 特点：
     * - 所有关节松弛，无主动控制
     * - 机器人会在重力作用下趴下
     * - 最安全的状态，紧急时使用
     * - 系统启动时的初始状态
     */
    L2_B,       // passive

    /**
     * @brief 自由站立指令
     * 
     * 触发方式：
     * - 遥控器：L2+X按键组合
     * - 键盘：'3'键
     * 
     * 功能：让机器人进入可调节的站立状态
     * 目标状态：FSMStateName::FREESTAND
     * 
     * 特点：
     * - 可以通过用户输入调节机体姿态
     * - 支持俯仰、翻滚、偏航角度调节
     * - 支持机体高度调节
     * - 便于测试和演示
     */
    L2_X,       // freeStand

#ifdef COMPILE_WITH_MOVE_BASE
    /**
     * @brief 导航基座指令（可选编译）
     * 
     * 触发方式：
     * - 遥控器：L2+Y按键组合
     * 
     * 功能：让机器人进入基于ROS导航栈的自主导航状态
     * 目标状态：FSMStateName::MOVE_BASE
     * 
     * 特点：
     * - 集成ROS move_base导航功能
     * - 支持地图构建和路径规划
     * - 可以自主避障和导航
     * - 需要额外的传感器支持（激光雷达、相机等）
     * 
     * 编译条件：需要定义COMPILE_WITH_MOVE_BASE宏
     */
    L2_Y,       // move_base
#endif  // COMPILE_WITH_MOVE_BASE

    /**
     * @brief 平衡测试指令
     * 
     * 触发方式：
     * - 遥控器：L1+X按键组合
     * 
     * 功能：进入专门的平衡性能测试状态
     * 目标状态：FSMStateName::BALANCETEST
     * 
     * 特点：
     * - 测试机器人的平衡控制算法
     * - 可以施加外部干扰进行测试
     * - 记录和分析平衡性能数据
     * - 主要用于算法验证和参数调优
     */
    L1_X,       // balanceTest

    /**
     * @brief 摆动测试指令
     * 
     * 触发方式：
     * - 遥控器：L1+A按键组合
     * 
     * 功能：进入单腿摆动测试状态
     * 目标状态：FSMStateName::SWINGTEST
     * 
     * 特点：
     * - 测试单腿的运动学和控制性能
     * - 可以通过用户输入控制足端位置
     * - 验证逆运动学算法的准确性
     * - 检查关节控制的精度
     */
    L1_A,       // swingTest

    /**
     * @brief 步伐测试指令
     * 
     * 触发方式：
     * - 遥控器：L1+Y按键组合
     * 
     * 功能：进入步伐序列测试状态
     * 目标状态：FSMStateName::STEPTEST
     * 
     * 特点：
     * - 测试预定义的步伐序列
     * - 验证步态生成器的功能
     * - 分析步态的稳定性和效率
     * - 为复杂步态开发提供基础
     */
    L1_Y        // stepTest
};

/**
 * @brief 坐标系类型枚举
 * 
 * 定义了四足机器人控制系统中使用的不同参考坐标系。
 * 不同的算法和计算可能需要在不同坐标系下进行，这个枚举统一了坐标系的表示。
 * 
 * 坐标系转换是机器人学的核心概念，正确的坐标系选择对算法的准确性至关重要。
 */
enum class FrameType{
    /**
     * @brief 机体坐标系
     * 
     * 定义：
     * - 原点：机器人几何中心（通常是重心附近）
     * - X轴：指向机器人前方（机器人前进方向）
     * - Y轴：指向机器人左侧（右手坐标系）
     * - Z轴：垂直向上（与重力方向相反）
     * 
     * 特点：
     * - 随机器人运动而运动的动态坐标系
     * - 机器人控制中最常用的坐标系
     * - 便于描述机器人相对于自身的运动
     * - 步态规划和平衡控制的主要参考系
     * 
     * 应用场景：
     * - 足端轨迹规划
     * - 重心控制
     * - 姿态调节
     * - 步态生成
     */
    BODY,

    /**
     * @brief 髋关节坐标系
     * 
     * 定义：
     * - 原点：各髋关节的位置
     * - X轴：指向机器人前方
     * - Y轴：指向机器人左侧  
     * - Z轴：垂直向上
     * 
     * 特点：
     * - 每条腿都有自己的髋关节坐标系
     * - 方便进行单腿运动学计算
     * - 简化了腿部逆运动学的数学表达
     * - 与机体坐标系只有平移变换关系
     * 
     * 应用场景：
     * - 腿部逆运动学求解
     * - 关节角度计算
     * - 腿部工作空间分析
     * - 关节限制检查
     */
    HIP,

    /**
     * @brief 全局坐标系（世界坐标系）
     * 
     * 定义：
     * - 原点：固定在世界中的某个位置（如机器人初始位置）
     * - X轴：通常指向东方或前方
     * - Y轴：通常指向北方或左方
     * - Z轴：垂直向上（与重力方向相反）
     * 
     * 特点：
     * - 固定不动的绝对参考坐标系
     * - 用于描述机器人在世界中的绝对位置和运动
     * - SLAM和导航系统的主要参考系
     * - 便于多机器人协调和环境建模
     * 
     * 应用场景：
     * - 路径规划和导航
     * - SLAM建图和定位
     * - 多机器人协调
     * - 地图构建和环境感知
     */
    GLOBAL
};

/**
 * @brief 步态波形状态枚举
 * 
 * 描述四足机器人在步态执行过程中的整体状态。
 * 这个枚举用于步态生成器（WaveGenerator）来判断当前的步态阶段。
 * 
 * 步态是四条腿协调运动的模式，不同的步态状态决定了：
 * - 哪些腿在支撑（与地面接触）
 * - 哪些腿在摆动（在空中运动）
 * - 腿部之间的相位关系
 */
enum class WaveStatus{
    /**
     * @brief 全支撑阶段
     * 
     * 特点：
     * - 所有四条腿都与地面接触
     * - 机器人处于最稳定的状态
     * - 可以承受最大的外部干扰
     * - 足端主要执行支撑和推进功能
     * 
     * 应用场景：
     * - 静态站立
     * - 准备起步时的稳定阶段
     * - 受到外部冲击时的紧急支撑
     * - 低速行走的稳定相
     */
    STANCE_ALL,

    /**
     * @brief 全摆动阶段（理论状态）
     * 
     * 特点：
     * - 理论上所有腿都在空中
     * - 实际机器人中极少出现这种状态
     * - 仅在跳跃动作的空中阶段可能出现
     * - 机器人完全依靠惯性运动
     * 
     * 应用场景：
     * - 跳跃动作的空中阶段
     * - 特殊运动模式（如跳跃步态）
     * - 极限运动测试
     * 
     * 注意：这种状态下机器人无法控制位置，只能调节姿态
     */
    SWING_ALL,

    /**
     * @brief 波浪状态（正常步态）
     * 
     * 特点：
     * - 部分腿支撑，部分腿摆动
     * - 最常见的动态行走状态
     * - 腿部按照特定相位序列轮流支撑和摆动
     * - 保持动态稳定性
     * 
     * 应用场景：
     * - Trot步态（小跑）：对角线腿同步
     * - Walk步态（行走）：腿部依次抬起
     * - Bound步态（跳跃）：前后腿分别同步
     * - 所有实用的动态步态
     * 
     * 这是机器人正常行走时的主要状态
     */
    WAVE_ALL
};

/**
 * @brief 有限状态机模式枚举
 * 
 * 描述状态机当前的工作模式，用于控制状态转换的执行流程。
 * 状态机需要在状态转换时进行特殊处理，这个枚举帮助区分正常运行和转换过程。
 */
enum class FSMMode{
    /**
     * @brief 正常运行模式
     * 
     * 特点：
     * - 状态机处于稳定状态
     * - 当前状态正常执行其控制逻辑
     * - 定期检查状态转换条件
     * - 系统处于正常控制循环中
     * 
     * 工作流程：
     * 1. 执行当前状态的run()函数
     * 2. 检查checkChange()返回值
     * 3. 如果需要转换，切换到CHANGE模式
     * 4. 如果不需要转换，继续NORMAL模式
     */
    NORMAL,

    /**
     * @brief 状态转换模式
     * 
     * 特点：
     * - 状态机正在执行状态转换
     * - 涉及旧状态的退出和新状态的进入
     * - 确保转换过程的原子性和安全性
     * - 转换完成后返回NORMAL模式
     * 
     * 工作流程：
     * 1. 调用当前状态的exit()函数
     * 2. 切换状态指针到新状态
     * 3. 调用新状态的enter()函数
     * 4. 切换回NORMAL模式
     * 5. 执行新状态的run()函数
     * 
     * 安全保证：
     * - 状态转换过程不会被中断
     * - 确保资源的正确释放和获取
     * - 防止状态转换过程中的竞争条件
     */
    CHANGE
};

/**
 * @brief 有限状态机状态名枚举
 * 
 * 定义了机器人控制系统中所有可能的行为状态。
 * 每个状态代表一种特定的机器人行为模式和控制策略。
 * 
 * 状态设计遵循单一职责原则，每个状态专注于一种特定的机器人行为。
 * 状态之间通过明确定义的转换条件进行切换，保证系统的确定性和可预测性。
 */
enum class FSMStateName{
    // EXIT,        // 未使用，可能用于程序退出

    /**
     * @brief 无效状态
     * 
     * 用途：
     * - 状态机初始化时的默认状态
     * - 错误处理：当出现未知状态转换时
     * - 调试辅助：标识异常的状态转换请求
     * 
     * 特点：
     * - 不执行任何控制逻辑
     * - 通常会触发错误处理或安全保护
     * - 帮助发现状态机设计中的问题
     */
    INVALID,

    /**
     * @brief 被动状态
     * 
     * 功能：机器人完全放松，不进行主动控制
     * 
     * 特点：
     * - 所有关节力矩设为0或极小值
     * - 机器人在重力作用下自然趴下
     * - 最安全的状态，适合紧急停机
     * - 系统启动后的初始状态
     * 
     * 应用场景：
     * - 系统初始化
     * - 紧急停机
     * - 安全保护触发后
     * - 低电量保护
     * 
     * 转换条件：
     * - 从任何状态都可以切换到PASSIVE（安全优先）
     * - 用户主动指令：L2+B
     * - 系统安全检查失败时自动切换
     */
    PASSIVE,

    /**
     * @brief 固定站立状态
     * 
     * 功能：机器人保持固定的站立姿态
     * 
     * 特点：
     * - 关节角度控制到预设的站立位置
     * - 具备一定的抗干扰能力
     * - 为动态运动做准备的稳定基础
     * - 功耗相对较低
     * 
     * 控制策略：
     * - 位置控制模式（PD控制）
     * - 目标位置为理想站立配置
     * - 较高的位置增益，中等的阻尼增益
     * 
     * 应用场景：
     * - 从PASSIVE状态启动后的第一步
     * - 动态运动前的准备状态
     * - 需要稳定站立时（如等待指令）
     * 
     * 转换条件：
     * - 从PASSIVE状态通过L2+A指令进入
     * - 可以转换到其他运动状态
     * - 安全检查失败时退回PASSIVE
     */
    FIXEDSTAND,

    /**
     * @brief 自由站立状态
     * 
     * 功能：可调节姿态的交互式站立状态
     * 
     * 特点：
     * - 支持机体姿态的实时调节
     * - 可以调节俯仰、翻滚、偏航角度
     * - 可以调节机体高度
     * - 响应用户的实时输入
     * 
     * 控制策略：
     * - 基于目标姿态的位置控制
     * - 实时根据用户输入更新目标
     * - 平滑的姿态过渡
     * 
     * 应用场景：
     * - 姿态展示和演示
     * - 传感器标定
     * - 用户交互和娱乐
     * - 姿态控制算法测试
     * 
     * 转换条件：
     * - 从FIXEDSTAND通过L2+X指令进入
     * - 可以返回FIXEDSTAND或进入其他状态
     */
    FREESTAND,

    /**
     * @brief 小跑步态状态
     * 
     * 功能：机器人的主要动态行走状态
     * 
     * 特点：
     * - 对角线腿同步的动态步态
     * - 支持前进、后退、转向运动
     * - 具备良好的运动效率和稳定性
     * - 适合大部分地形和速度范围
     * 
     * 控制策略：
     * - 基于模型预测控制（MPC）或类似方法
     * - 结合足端轨迹规划和重心控制
     * - 实时步态参数调节
     * 
     * 步态参数：
     * - 步态周期：通常0.4-0.5秒
     * - 支撑相比例：约50%
     * - 相位差：对角线腿相位差π
     * 
     * 应用场景：
     * - 日常移动和导航
     * - 中等速度的运动
     * - 大部分实际应用场景
     * 
     * 转换条件：
     * - 从FIXEDSTAND通过START指令进入
     * - 是最主要的工作状态
     */
    TROTTING,

#ifdef COMPILE_WITH_MOVE_BASE
    /**
     * @brief 导航基座状态（可选编译）
     * 
     * 功能：集成ROS导航栈的自主导航状态
     * 
     * 特点：
     * - 接收move_base导航指令
     * - 支持路径规划和避障
     * - 集成SLAM和定位功能
     * - 与ROS生态系统深度集成
     * 
     * 控制策略：
     * - 将导航指令转换为机器人运动命令
     * - 在TROTTING基础上增加导航逻辑
     * - 处理局部路径规划和避障
     * 
     * 应用场景：
     * - 自主导航任务
     * - 复杂环境中的路径规划
     * - 多点巡逻和配送
     * - 与其他ROS节点的协同工作
     * 
     * 编译条件：需要定义COMPILE_WITH_MOVE_BASE宏
     * 
     * 转换条件：
     * - 从TROTTING状态通过L2+Y指令进入
     * - 需要导航任务时自动激活
     */
    MOVE_BASE,       // move_base
#endif  // COMPILE_WITH_MOVE_BASE

    /**
     * @brief 平衡测试状态
     * 
     * 功能：专门用于测试和验证机器人平衡控制算法
     * 
     * 特点：
     * - 重点测试抗干扰能力
     * - 记录和分析平衡性能数据
     * - 可以施加已知的外部干扰
     * - 提供详细的性能指标
     * 
     * 测试内容：
     * - 静态平衡：保持固定姿态的能力
     * - 动态平衡：运动中的稳定性
     * - 干扰恢复：受到推力后的恢复能力
     * - 极限测试：最大干扰承受能力
     * 
     * 控制策略：
     * - 基于力控制的平衡算法
     * - 实时重心调节
     * - 足端力分配优化
     * - 姿态快速恢复控制
     * 
     * 应用场景：
     * - 算法开发和调试
     * - 性能评估和对比
     * - 参数优化
     * - 学术研究和验证
     * 
     * 转换条件：
     * - 从FIXEDSTAND通过L1+X指令进入
     * - 主要用于开发和测试阶段
     */
    BALANCETEST,

    /**
     * @brief 摆动测试状态
     * 
     * 功能：测试单腿运动学和控制性能
     * 
     * 特点：
     * - 专注于单腿的精确控制
     * - 测试逆运动学算法的准确性
     * - 验证关节控制器的性能
     * - 检查工作空间的覆盖范围
     * 
     * 测试内容：
     * - 位置控制精度：足端是否能到达目标位置
     * - 运动平滑性：轨迹跟踪的连续性
     * - 速度控制：足端速度的准确性
     * - 关节限制：是否超出安全范围
     * 
     * 控制策略：
     * - 基于逆运动学的位置控制
     * - 用户输入直接控制足端目标位置
     * - 实时显示当前足端位置和目标位置
     * - 可选的轨迹记录和分析
     * 
     * 用户交互：
     * - 通过遥控器摇杆控制足端X、Y、Z坐标
     * - 实时响应用户输入
     * - 提供视觉反馈
     * 
     * 应用场景：
     * - 运动学算法验证
     * - 关节控制器调试
     * - 机械结构检查
     * - 教学演示
     * 
     * 转换条件：
     * - 从FIXEDSTAND通过L1+A指令进入
     * - 通常其他三腿保持支撑，一腿进行摆动测试
     */
    SWINGTEST,

    /**
     * @brief 步伐测试状态
     * 
     * 功能：测试预定义的步伐序列和步态基础功能
     * 
     * 特点：
     * - 执行预编程的步伐序列
     * - 测试步态生成器的基础功能
     * - 验证腿部协调的正确性
     * - 分析步态的稳定性和效率
     * 
     * 测试内容：
     * - 步态时序：各腿抬起和落下的时间准确性
     * - 相位关系：腿部之间的协调是否正确
     * - 稳定性分析：重心轨迹和支撑多边形
     * - 能耗分析：不同步态的效率对比
     * 
     * 控制策略：
     * - 基于预定义轨迹的开环控制
     * - 固定的步态参数和时序
     * - 重复执行标准步伐模式
     * - 详细的数据记录和分析
     * 
     * 步伐类型：
     * - 基础Trot步态测试
     * - 单步前进/后退
     * - 原地踏步
     * - 转向步伐
     * 
     * 应用场景：
     * - 步态算法开发
     * - 步态参数优化
     * - 机器人性能基准测试
     * - 故障诊断和检查
     * 
     * 转换条件：
     * - 从FIXEDSTAND通过L1+Y指令进入
     * - 为复杂步态开发提供基础验证
     */
    STEPTEST
};

#endif  // ENUMCLASS_H

/*
* ==================== 枚举类型使用指南 ====================
* 
* ## 🎯 类型安全的优势
* 
* 使用enum class而不是传统enum的好处：
* 
* ```cpp
* // ❌ 传统enum的问题
* enum OldFrameType { BODY, HIP, GLOBAL };
* enum OldRobotType { A1, BODY };  // 命名冲突！
* int x = BODY;  // 隐式转换为整数
* 
* // ✅ enum class的优势  
* enum class FrameType { BODY, HIP, GLOBAL };
* enum class RobotType { A1, Go1 };
* FrameType frame = FrameType::BODY;  // 必须显式指定作用域
* // int x = FrameType::BODY;  // 编译错误，无隐式转换
* ```
* 
* ## 🔄 状态转换映射表
* 
* | 用户输入 | 物理按键 | 目标状态 | 前置条件 |
* |---------|---------|---------|----------|
* | NONE | 无 | 保持当前 | - |
* | L2_B | L2+B | PASSIVE | 任何状态 |
* | L2_A | L2+A/'2' | FIXEDSTAND | 从PASSIVE |
* | L2_X | L2+X/'3' | FREESTAND | 从FIXEDSTAND |
* | START | START/'4' | TROTTING | 从FIXEDSTAND |
* | L2_Y | L2+Y | MOVE_BASE | 从TROTTING |
* | L1_X | L1+X | BALANCETEST | 从FIXEDSTAND |
* | L1_A | L1+A | SWINGTEST | 从FIXEDSTAND |
* | L1_Y | L1+Y | STEPTEST | 从FIXEDSTAND |
* 
* ## 🚦 安全状态转换规则
* 
* 1. **安全优先原则**：
*    - 任何状态都可以立即切换到PASSIVE
*    - PASSIVE是最安全的紧急状态
* 
* 2. **渐进激活原则**：
*    - PASSIVE → FIXEDSTAND → 其他动态状态
*    - 不能直接从PASSIVE跳到动态状态
* 
* 3. **功能分离原则**：
*    - 测试状态（BALANCETEST、SWINGTEST、STEPTEST）只能从FIXEDSTAND进入
*    - 避免测试功能影响正常运行
* 
* 4. **条件检查原则**：
*    - 每个状态转换都要通过安全检查
*    - 电池电量、传感器状态、机械限制等
* 
* ## 📊 坐标系转换关系
* 
* ```
* GLOBAL (世界坐标系)
*    ↕ 旋转+平移变换
* BODY (机体坐标系)  
*    ↕ 平移变换
* HIP (髋关节坐标系)
* ```
* 
* 转换特点：
* - BODY ↔ HIP：仅有平移，无旋转
* - GLOBAL ↔ BODY：需要完整的刚体变换
* - 计算效率：HIP > BODY > GLOBAL
* 
* ## 🎮 用户输入处理流程
* 
* ```
* 物理输入设备
*      ↓
* IOInterface解析
*      ↓  
* UserCommand枚举
*      ↓
* FSMState::checkChange()
*      ↓
* FSMStateName返回
*      ↓
* FSM状态转换执行
* ```
* 
* ## 🔧 扩展新枚举类型的步骤
* 
* 1. **定义新枚举**：
*    ```cpp
*    enum class NewEnumType {
*        VALUE1,
*        VALUE2,
*        // ...
*    };
*    ```
* 
* 2. **更新相关类和函数**：
*    - 添加对应的处理逻辑
*    - 更新switch-case语句
*    - 添加必要的转换函数
* 
* 3. **文档更新**：
*    - 更新本文件的注释
*    - 添加使用示例
*    - 更新用户手册
* 
* ## 💡 最佳实践建议
* 
* 1. **命名规范**：
*    - 枚举类名使用PascalCase
*    - 枚举值使用UPPER_CASE
*    - 名称要具有自解释性
* 
* 2. **作用域管理**：
*    - 始终使用完整的作用域名称
*    - 避免using namespace或using声明
* 
* 3. **扩展性设计**：
*    - 预留扩展空间
*    - 保持向后兼容性
*    - 版本化管理枚举更改
* 
* 4. **类型转换**：
*    - 避免强制类型转换
*    - 提供专用的转换函数
*    - 进行范围检查
*/