/**********************************************************************
Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/*
* ================================================================
* 文件名：ControlFrame.h
* 作用：四足机器人主控制框架
* 
* 核心功能：
* - 作为整个控制系统的顶层调度器和协调中心
* - 管理有限状态机(FSM)的运行，控制机器人的行为状态
* - 协调各个控制组件的工作，确保系统有序运行
* - 提供统一的控制循环入口，实现500Hz的实时控制
* 
* 设计思想：
* ControlFrame采用"控制框架+状态机"的架构模式：
* - 控制框架负责系统级的资源管理和调度
* - 状态机负责具体的行为逻辑和状态转换
* - 两者分离，提高系统的模块化程度和可维护性
* ================================================================
*/

#ifndef CONTROLFRAME_H
#define CONTROLFRAME_H

#include "FSM/FSM.h"                    // 有限状态机基类
#include "control/CtrlComponents.h"     // 控制组件集合

/**
* @brief 四足机器人主控制框架类
* 
* 这是整个控制系统的最高层抽象，负责：
* 1. 管理和调度有限状态机的执行
* 2. 协调各个控制组件的工作流程  
* 3. 提供统一的控制循环接口
* 4. 确保实时控制的时序要求
* 
* 工作流程：
* main() → ControlFrame::run() → FSM::run() → State::run()
*   ↑                                              ↓
*   └──── 500Hz循环 ←──── 控制命令输出 ←──────────────┘
*/
class ControlFrame{
public:
	/**
	* @brief 构造函数
	* 初始化控制框架，创建并配置有限状态机
	* 
	* @param ctrlComp 控制组件集合指针，包含：
	*                 - 机器人模型(robotModel)
	*                 - 状态估计器(estimator)  
	*                 - 平衡控制器(balCtrl)
	*                 - 步态生成器(waveGen)
	*                 - IO接口(ioInter)
	*                 - 底层命令和状态(lowCmd, lowState)
	*                 - 控制参数(dt, contact, phase等)
	* 
	* 构造过程：
	* 1. 保存控制组件的引用
	* 2. 创建有限状态机实例  
	* 3. 将控制组件传递给状态机进行初始化
	* 4. 状态机会自动进入初始状态(通常是PASSIVE)
	*/
	ControlFrame(CtrlComponents *ctrlComp);
	
	/**
	* @brief 析构函数
	* 清理资源，删除有限状态机对象
	* 
	* 注意：只删除FSM对象，不删除CtrlComponents，
	* 因为CtrlComponents在main函数中管理其生命周期
	*/
	~ControlFrame(){
		delete _FSMController;
	}
	
	/**
	* @brief 主控制循环执行方法
	* 这是整个控制系统的核心入口，每个控制周期(500Hz)被调用一次
	* 
	* 执行流程：
	* 1. 调用状态机的run()方法
	* 2. 状态机内部会：
	*    a) 检查状态转换条件
	*    b) 执行当前状态的控制逻辑
	*    c) 更新系统状态
	*    d) 生成控制命令
	* 3. 控制命令通过IO接口发送给机器人
	* 
	* 调用上下文：
	* - 在main()函数的while(running)循环中被调用
	* - 调用频率：500Hz (每2ms执行一次)
	* - 实时性要求：必须在2ms内完成所有计算
	* 
	* 典型的控制流程：
	* run() → FSM::run() → currentState::run() → 
	* getUserCmd() → calcTau() → calcQQd() → calcCmd() → sendRecv()
	*/
	void run();

private:
	// ==================== 核心组件 ====================
	
	/**
	* @brief 有限状态机控制器指针
	* 
	* 状态机负责管理机器人的行为状态和状态转换：
	* - PASSIVE: 被动模式，关节松弛，等待激活
	* - FIXEDSTAND: 固定站立，关节锁定在站立位置
	* - TROTTING: 小跑步态，动态运动状态
	* - ... (其他扩展状态)
	* 
	* 状态转换通常由以下条件触发：
	* - 用户命令 (键盘输入、遥控器指令)
	* - 系统状态 (传感器反馈、安全检查)
	* - 定时器 (状态持续时间限制)
	* 
	* FSM的设计确保了机器人行为的：
	* - 确定性：相同输入产生相同输出
	* - 安全性：状态转换遵循预定义的安全规则
	* - 可预测性：行为模式清晰可控
	*/
	FSM* _FSMController;
	
	/**
	* @brief 控制组件集合指针
	* 
	* 指向包含所有控制相关组件的结构体，包括：
	* 
	* 硬件接口层：
	* - ioInter: IO通信接口 (SDK或ROS)
	* - lowCmd: 底层控制命令 (关节位置、速度、力矩)
	* - lowState: 底层状态反馈 (关节状态、IMU数据等)
	* 
	* 算法组件层：
	* - robotModel: 机器人运动学/动力学模型
	* - estimator: 状态估计器 (姿态、位置、速度估计)
	* - balCtrl: 平衡控制器 (力分配、姿态控制)
	* - waveGen: 波形生成器 (步态节拍、相位计算)
	* 
	* 状态变量层：
	* - contact: 足端接触状态 [1,0,0,1]
	* - phase: 步态相位 [0.0,0.5,0.5,0.0]
	* - dt: 控制周期 (0.002s = 500Hz)
	* 
	* 系统参数层：
	* - ctrlPlatform: 控制平台类型 (GAZEBO/REALROBOT)
	* - running: 系统运行标志
	* 
	* 这种组件化设计的优势：
	* - 模块化：每个组件职责单一，易于维护
	* - 可复用：组件可在不同状态间共享使用
	* - 可测试：每个组件可独立测试和验证
	* - 可扩展：新功能可通过添加组件实现
	*/
	CtrlComponents *_ctrlComp;
};

#endif  //CONTROLFRAME_H

/*
* ================================================================
* 架构设计模式分析：
* 
* 1. 分层架构 (Layered Architecture)：
*    应用层：ControlFrame (系统调度)
*    业务层：FSM (状态逻辑)  
*    服务层：CtrlComponents (算法组件)
*    数据层：lowCmd/lowState (硬件接口)
* 
* 2. 状态模式 (State Pattern)：
*    - Context: ControlFrame + FSM
*    - State: PASSIVE, FIXEDSTAND, TROTTING等
*    - 状态转换由外部事件和内部条件触发
* 
* 3. 外观模式 (Facade Pattern)：
*    - ControlFrame为复杂的控制子系统提供统一接口
*    - 隐藏内部组件的复杂交互细节
*    - 简化外部调用者(main函数)的使用方式
* 
* 4. 依赖注入 (Dependency Injection)：
*    - 通过构造函数注入CtrlComponents依赖
*    - 提高了组件间的松耦合度
*    - 便于单元测试和模块替换
* 
* 5. 实时系统设计原则：
*    - 确定性执行：每次run()调用的执行路径可预测
*    - 有界延迟：所有操作必须在2ms内完成
*    - 资源隔离：避免动态内存分配和阻塞操作
* ================================================================
*/