/**********************************************************************
 Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/**
 * @file CmdPanel.h
 * @brief 命令面板抽象基类 - Unitree四足机器人用户输入处理接口
 * 
 * 文件作用：
 * 这个文件定义了机器人用户输入处理的抽象基类，负责统一管理来自不同输入设备
 * （键盘、无线手柄等）的用户命令。它是整个控制系统中用户交互的核心接口，
 * 将多样化的输入设备抽象为统一的命令格式，供上层控制逻辑使用。
 * 
 * 主要功能：
 * 1. 用户命令抽象：将不同输入设备的信号统一为标准的用户命令格式
 * 2. 摇杆数值处理：标准化处理模拟摇杆的连续数值输入
 * 3. 状态管理：维护用户输入的当前状态和历史变化
 * 4. 安全控制：提供紧急停止和被动模式切换功能
 * 5. 多线程支持：支持在独立线程中处理用户输入，避免阻塞主控制循环
 * 
 * 设计模式：
 * - 抽象基类模式：定义统一的输入处理接口
 * - 模板方法模式：提供通用的输入处理流程框架
 * - 策略模式：不同输入设备使用不同的处理策略
 */

#ifndef CMDPANEL_H
#define CMDPANEL_H

// ==================== 头文件依赖 ====================
#include "message/unitree_joystick.h"    // 手柄消息定义，包含按键和摇杆数据结构
#include "common/enumClass.h"            // 枚举类定义，包含UserCommand等枚举类型
#include <pthread.h>                     // POSIX线程库，用于多线程输入处理

// ==================== 条件编译 - 真实机器人支持 ====================
#ifdef COMPILE_WITH_REAL_ROBOT
    #ifdef ROBOT_TYPE_A1
        #include "unitree_legged_sdk/unitree_legged_sdk.h"  // A1机器人SDK头文件
    #endif  // ROBOT_TYPE_A1
    #ifdef ROBOT_TYPE_Go1
        #include "unitree_legged_sdk/unitree_legged_sdk.h" // Go1机器人SDK头文件
    #endif  // ROBOT_TYPE_Go1
#endif  // COMPILE_WITH_REAL_ROBOT

/**
 * @struct UserValue
 * @brief 用户输入数值结构体
 * 
 * 这个结构体封装了来自模拟输入设备（如手柄摇杆）的连续数值，
 * 主要用于控制机器人的移动方向和速度。所有数值都被标准化到
 * 合理的范围内，便于后续的控制算法处理。
 * 
 * 坐标系统约定：
 * - lx, ly: 左摇杆的 X-Y 轴数值，通常用于控制机器人的平移运动
 * - rx, ry: 右摇杆的 X-Y 轴数值，通常用于控制机器人的旋转运动
 * - L2: 模拟扳机的压力值，可用于控制运动强度或特殊功能
 * 
 * 数值范围：通常为 [-1.0, 1.0]，其中：
 * - 0.0 表示中性位置（无输入）
 * - 正值表示正方向运动
 * - 负值表示负方向运动
 */
struct UserValue{
    float lx;    ///< 左摇杆X轴数值：控制前后移动（向前为正，向后为负）
    float ly;    ///< 左摇杆Y轴数值：控制左右平移（向右为正，向左为负）
    float rx;    ///< 右摇杆X轴数值：控制偏航旋转（顺时针为正，逆时针为负）
    float ry;    ///< 右摇杆Y轴数值：控制俯仰姿态（抬头为正，低头为负）
    float L2;    ///< L2扳机数值：控制运动增益或特殊功能触发（按下程度0.0~1.0）
    
    /**
     * @brief 默认构造函数
     * 
     * 初始化所有数值为零，确保结构体在创建时处于安全的中性状态。
     * 这样可以避免未初始化数据导致的意外机器人运动。
     */
    UserValue(){
        setZero();  // 调用清零函数，初始化所有成员为0
    }
    
    /**
     * @brief 数值清零函数
     * 
     * 将所有输入数值重置为0，相当于将所有输入设备回归到中性位置。
     * 这个函数通常在以下情况调用：
     * - 初始化时：确保起始状态安全
     * - 紧急停止时：立即停止所有用户输入
     * - 状态切换时：清除上一状态的输入残留
     */
    void setZero(){
        lx = 0;  // 左摇杆X轴清零
        ly = 0;  // 左摇杆Y轴清零
        rx = 0;  // 右摇杆X轴清零
        ry = 0;  // 右摇杆Y轴清零
        L2 = 0;  // L2扳机清零
    }
};

/**
 * @class CmdPanel
 * @brief 命令面板抽象基类
 * 
 * 这是所有用户输入处理类的基类，提供了统一的接口来处理不同类型的
 * 用户输入设备。通过这个抽象接口，上层控制代码可以透明地使用
 * 键盘、无线手柄或其他输入设备，而无需关心具体的设备类型。
 * 
 * 主要职责：
 * 1. 输入抽象：将不同设备的输入统一为标准格式
 * 2. 状态管理：维护用户命令和数值的当前状态
 * 3. 线程安全：提供线程安全的输入处理机制
 * 4. 安全控制：提供紧急控制和状态重置功能
 * 
 * 继承关系：
 * CmdPanel (基类)
 *   ├── KeyBoard        (键盘输入处理)
 *   └── WirelessHandle  (无线手柄处理)
 * 
 * 使用模式：
 * - 工厂模式：根据配置创建不同的输入设备处理器
 * - 观察者模式：控制系统观察输入状态的变化
 */
class CmdPanel{
public:
    /**
     * @brief 默认构造函数
     * 
     * 创建命令面板对象，初始化基础状态。派生类需要在自己的
     * 构造函数中完成具体设备的初始化工作。
     */
    CmdPanel(){}
    
    /**
     * @brief 虚析构函数
     * 
     * 使用虚析构函数确保派生类对象能够正确清理资源，
     * 避免内存泄漏和资源未释放的问题。
     */
    virtual ~CmdPanel(){}

    // ==================== 公共接口函数 ====================

    /**
     * @brief 获取当前用户命令
     * @return UserCommand 当前的用户命令状态
     * 
     * 返回最新的离散用户命令（如按键状态），这些命令通常用于
     * 控制机器人的状态切换，如：
     * - 站立/坐下切换
     * - 步态模式选择  
     * - 紧急停止等
     * 
     * 线程安全性：这个函数可以在多线程环境中安全调用
     */
    UserCommand getUserCmd(){return userCmd;}
    
    /**
     * @brief 获取当前用户数值
     * @return UserValue 当前的用户输入数值
     * 
     * 返回最新的连续数值输入（如摇杆位置），这些数值通常用于
     * 控制机器人的连续运动，如：
     * - 行走速度和方向
     * - 转向角度
     * - 身体姿态调整
     * 
     * 线程安全性：这个函数可以在多线程环境中安全调用
     */
    UserValue getUserValue(){return userValue;}
    
    /**
     * @brief 设置为被动模式
     * 
     * 立即将机器人切换到被动（安全）模式，这通常意味着：
     * - 关闭所有主动控制
     * - 机器人进入最安全的状态
     * - 停止当前执行的动作
     * 
     * 安全性：这是一个安全函数，可以在任何时候调用来确保机器人安全
     * 应用场景：
     * - 紧急停止时
     * - 系统初始化时
     * - 错误恢复时
     */
    void setPassive(){userCmd = UserCommand::L2_B;}
    
    /**
     * @brief 清零所有用户数值
     * 
     * 重置所有连续输入数值为0，相当于将所有模拟输入设备
     * 回归到中性位置。这个函数通常在状态切换或紧急情况下调用。
     * 
     * 注意：这个函数只清零数值输入，不影响离散命令状态
     */
    void setZero(){userValue.setZero();}

    // ==================== 条件编译 - 真实机器人支持 ====================

#ifdef COMPILE_WITH_REAL_ROBOT
    /**
     * @brief 处理真实机器人的状态反馈 [虚函数]
     * @param lowState 来自真实机器人的底层状态数据
     * 
     * 这个函数在真实机器人模式下被调用，用于处理从机器人硬件
     * 接收到的状态信息。派生类可以重写这个函数来实现特定的
     * 状态处理逻辑。
     * 
     * 功能说明：
     * - 接收机器人的实时状态数据
     * - 根据机器人状态调整输入处理策略
     * - 实现基于状态的安全检查
     * 
     * 调用时机：每次接收到机器人状态更新时
     * 默认实现：空函数，派生类根据需要重写
     */
    virtual void receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState){};
#endif  // COMPILE_WITH_REAL_ROBOT

protected:
    // ==================== 受保护成员 - 供派生类使用 ====================

    /**
     * @brief 线程运行函数 [虚函数]
     * @param arg 线程参数（通常为this指针）
     * @return void* 线程返回值
     * 
     * 这是多线程输入处理的核心函数，派生类需要重写这个函数
     * 来实现具体的输入处理逻辑。
     * 
     * 典型实现模式：
     * 1. 初始化输入设备
     * 2. 进入无限循环
     * 3. 读取设备输入
     * 4. 更新userCmd和userValue
     * 5. 适当的延时
     * 
     * 线程安全：这个函数运行在独立线程中，需要注意数据同步
     */
    virtual void* run(void *arg){return NULL;}

    /**
     * @brief 当前用户命令状态
     * 
     * 存储最新的离散用户命令，如按键状态。这个变量由派生类
     * 的输入处理逻辑更新，供上层控制系统读取。
     * 
     * 典型命令类型：
     * - L2_B: 被动模式（安全停止）
     * - L1_X: 站立模式
     * - L1_A: 行走模式
     * - START: 系统启动
     * 等等...
     */
    UserCommand userCmd;

    /**
     * @brief 当前用户输入数值
     * 
     * 存储最新的连续用户输入数值，如摇杆位置。这个变量由派生类
     * 的输入处理逻辑更新，供上层控制系统读取。
     * 
     * 更新频率：通常与输入设备的采样频率相同
     * 数据格式：标准化的浮点数值，范围通常为[-1.0, 1.0]
     */
    UserValue userValue;
};

#endif  // CMDPANEL_H