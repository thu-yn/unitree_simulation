/**********************************************************************
* 版权声明：Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
*
* 文件作用：
* 本文件定义了State_StepTest类，这是一个专门用于机器人步态测试的状态类。
* 该状态主要用于测试和验证机器人的单步运动能力，包括：
* 1. 单足或多足的抬起和落下动作
* 2. 步态参数的调试和优化
* 3. 平衡控制系统在步态切换时的响应测试
* 4. 足端轨迹跟踪的精度验证
* 
* 与其他状态的关系：
* - 作为Trotting状态的简化版本，专注于步态的基础测试
* - 可用于在进入复杂步态前的系统验证
* - 为步态参数调试提供独立的测试环境
***********************************************************************/

#ifndef STEPTEST_H
#define STEPTEST_H

#include "FSM/FSMState.h"

/**
* @brief 步态测试状态类
* 
* 这个状态类专门用于机器人的步态测试，提供了一个受控的环境来测试：
* - 单足抬起和着地的动作序列
* - 步态过程中的平衡控制效果
* - 足端力控制和位置控制的切换
* - 步态参数对机器人运动的影响
* 
* 设计特点：
* - 集成了完整的平衡控制器
* - 支持足端位置和力的精确控制
* - 具备完整的运动学和动力学计算
* - 可实现复杂的足端轨迹规划
*/
class State_StepTest : public FSMState{
public:
    /**
    * @brief 构造函数
    * @param ctrlComp 控制组件指针，提供对整个控制系统的访问
    * 
    * 初始化步态测试状态，设置状态名称和基本参数
    */
    State_StepTest(CtrlComponents *ctrlComp);
    
    /**
    * @brief 析构函数
    * 
    * 清理资源，由于使用的都是引用和指针，这里不需要特殊处理
    */
    ~State_StepTest(){}
    
    /**
    * @brief 进入步态测试状态时的初始化
    * 
    * 执行以下初始化操作：
    * - 记录机器人初始位置和姿态
    * - 设置步态相关的控制参数（刚度、阻尼等）
    * - 初始化足端位置目标和轨迹
    * - 配置平衡控制器的参数
    * - 重置步态相关的状态变量
    */
    void enter();
    
    /**
    * @brief 步态测试的主执行函数
    * 
    * 每个控制周期(500Hz)执行一次，主要功能：
    * 1. 获取当前机器人状态（关节角度、身体位置、姿态等）
    * 2. 根据步态规划计算期望的足端位置和速度
    * 3. 执行平衡控制算法，计算身体姿态补偿
    * 4. 计算每条腿的关节力矩命令
    * 5. 更新接触状态和步态相位
    * 6. 发送控制命令到机器人执行器
    */
    void run();
    
    /**
    * @brief 退出步态测试状态时的清理
    * 
    * 执行状态退出时的清理工作：
    * - 将控制模式切换为安全模式
    * - 保存测试过程中的关键数据
    * - 重置控制器状态，为下一个状态做准备
    */
    void exit();
    
    /**
    * @brief 检查状态转换条件
    * @return FSMStateName 下一个状态的名称，如果不需要转换则返回当前状态
    * 
    * 检查是否满足状态转换条件：
    * - 用户按键命令（退出到其他状态）
    * - 安全条件检查（异常情况下切换到被动状态）
    * - 测试完成条件（达到预定的测试目标）
    */
    FSMStateName checkChange();
    
private:
    // ==================== 私有方法 ====================
    
    /**
    * @brief 计算关节力矩命令
    * 
    * 这是步态测试的核心计算函数，综合考虑：
    * - 足端位置控制需要的关节力矩
    * - 身体平衡控制产生的补偿力矩
    * - 接触力控制对应的关节力矩
    * - 重力补偿和动力学补偿
    * 
    * 计算流程：
    * 1. 根据期望足端位置计算逆运动学
    * 2. 通过平衡控制器计算身体控制力
    * 3. 将足端力映射到关节空间
    * 4. 叠加各种补偿项得到最终的关节力矩
    */
    void calcTau();

    // ==================== 步态参数 ====================
    
    /**
    * @brief 步态高度参数
    * 
    * 控制机器人在步态测试中的身体高度，影响：
    * - 腿部的工作空间范围
    * - 步态的稳定裕度
    * - 能量消耗效率
    */
    float _gaitHeight;

    // ==================== 系统组件引用 ====================
    
    /**
    * @brief 状态估计器指针
    * 
    * 提供机器人当前状态的估计值：
    * - 身体位置、速度、加速度
    * - 身体姿态（Roll, Pitch, Yaw）和角速度
    * - 足端接触状态
    * - 外部扰动估计
    */
    Estimator *_est;
    
    /**
    * @brief 机器人模型指针
    * 
    * 提供机器人的运动学和动力学模型：
    * - 正逆运动学计算
    * - 雅可比矩阵计算
    * - 惯性参数和重心信息
    * - 关节限位和速度约束
    */
    QuadrupedRobot *_robModel;
    
    /**
    * @brief 平衡控制器指针
    * 
    * 实现机器人的平衡控制功能：
    * - 身体姿态稳定控制
    * - 重心位置控制
    * - 动态平衡算法
    * - 扰动抑制能力
    */
    BalanceCtrl *_balCtrl;

    // ==================== 步态状态变量 ====================
    
    /**
    * @brief 足端接触状态向量 (4维整数向量)
    * 
    * 每个元素对应一条腿的接触状态：
    * - 0: 该腿处于摆动相（不接触地面）
    * - 1: 该腿处于支撑相（接触地面）
    * 
    * 索引顺序：[前左, 前右, 后左, 后右]
    */
    VecInt4 *_contact;
    
    /**
    * @brief 步态相位向量 (4维浮点向量)
    * 
    * 每个元素表示对应腿在步态周期中的相位：
    * - 范围：[0, 1]
    * - 0.0: 该腿开始新的步态周期
    * - 0.5: 该腿处于步态周期中点
    * - 1.0: 该腿完成一个步态周期
    */
    Vec4 *_phase;

    // ==================== 控制目标参数 ====================
    
    /**
    * @brief 期望身体姿态旋转矩阵 (3x3旋转矩阵)
    * 
    * 定义机器人身体在世界坐标系中的期望姿态：
    * - 包含Roll、Pitch、Yaw三个旋转角度的信息
    * - 用于平衡控制器计算姿态误差
    * - 可根据用户命令或步态需要动态调整
    */
    RotMat _Rd;
    
    /**
    * @brief 期望身体重心位置 (3维位置向量)
    * 
    * 机器人身体重心在世界坐标系中的期望位置：
    * - [x, y, z]: 分别对应前后、左右、上下方向
    * - 用于位置控制和轨迹跟踪
    * - 影响机器人的整体运动方向
    */
    Vec3 _pcd;

    // ==================== 控制增益矩阵 ====================
    
    /**
    * @brief 位置控制比例增益矩阵 (3x3矩阵)
    * 
    * 用于身体位置控制的比例增益：
    * - 对角线元素分别对应x、y、z方向的增益
    * - 增益越大，位置跟踪越快但可能产生振荡
    * - 需要根据机器人特性和任务需求调整
    */
    Mat3 _Kpp;
    
    /**
    * @brief 姿态控制比例增益矩阵 (3x3矩阵)
    * 
    * 用于身体姿态控制的比例增益：
    * - 对角线元素分别对应Roll、Pitch、Yaw的增益
    * - 影响姿态响应的快速性和稳定性
    * - 与机器人的惯性特性密切相关
    */
    Mat3 _Kpw;
    
    /**
    * @brief 位置控制微分增益矩阵 (3x3矩阵)
    * 
    * 用于身体位置控制的微分增益：
    * - 提供阻尼效果，抑制振荡
    * - 基于速度误差计算控制输出
    * - 有助于提高系统的稳定性
    */
    Mat3 _Kdp;
    
    /**
    * @brief 姿态控制微分增益矩阵 (3x3矩阵)
    * 
    * 用于身体姿态控制的微分增益：
    * - 基于角速度误差提供阻尼
    * - 抑制姿态控制中的高频振荡
    * - 改善动态响应特性
    */
    Mat3 _Kdw;
    
    /**
    * @brief 摆动腿位置控制比例增益 (3x3矩阵)
    * 
    * 专门用于摆动相足端位置控制：
    * - 控制摆动腿足端跟踪期望轨迹的精度
    * - 与支撑腿的控制参数可能不同
    * - 影响足端轨迹的跟踪性能
    */
    Mat3 _KpSwing;
    
    /**
    * @brief 摆动腿位置控制微分增益 (3x3矩阵)
    * 
    * 用于摆动相足端速度控制：
    * - 提供足端运动的阻尼效果
    * - 减少足端轨迹跟踪中的振荡
    * - 改善摆动腿的运动平滑性
    */
    Mat3 _KdSwing;

    // ==================== 控制量计算结果 ====================
    
    /**
    * @brief 期望身体加速度 (3维加速度向量)
    * 
    * 平衡控制器计算出的身体重心期望加速度：
    * - [ddx, ddy, ddz]: 三个方向的线加速度分量
    * - 用于生成支撑腿需要提供的支撑力
    * - 是力控制和力矩计算的重要输入
    */
    Vec3 _ddPcd;
    
    /**
    * @brief 期望身体角加速度 (3维角加速度向量)
    * 
    * 平衡控制器计算出的身体期望角加速度：
    * - [ddroll, ddpitch, ddyaw]: 三个旋转方向的角加速度
    * - 用于计算维持姿态所需的控制力矩
    * - 影响机器人的姿态动态响应
    */
    Vec3 _dWbd;

    // ==================== 机器人状态变量 ====================
    
    /**
    * @brief 关节角度向量 (12维向量)
    * 
    * 存储所有关节的当前角度：
    * - 每条腿3个关节：髋关节、大腿关节、小腿关节
    * - 顺序：[FL_hip, FL_thigh, FL_calf, FR_hip, FR_thigh, FR_calf, 
    *          RL_hip, RL_thigh, RL_calf, RR_hip, RR_thigh, RR_calf]
    * - FL=前左, FR=前右, RL=后左, RR=后右
    */
    Vec12 _q;
    
    /**
    * @brief 关节力矩命令向量 (12维向量)
    * 
    * 输出给机器人执行器的关节力矩命令：
    * - 与关节角度向量对应相同的顺序
    * - 单位：牛顿·米 (N·m)
    * - 这是控制算法的最终输出
    */
    Vec12 _tau;
    
    /**
    * @brief 机身位置向量 (3维位置向量)
    * 
    * 机器人身体重心在世界坐标系中的当前位置：
    * - [x, y, z]: 世界坐标系中的三维坐标
    * - 来自状态估计器的融合结果
    * - 用于位置控制的反馈信号
    */
    Vec3 _posBody;
    
    /**
    * @brief 机身速度向量 (3维速度向量)
    * 
    * 机器人身体重心在世界坐标系中的当前速度：
    * - [vx, vy, vz]: 三个方向的线速度分量
    * - 用于速度控制和预测控制
    * - 是微分控制器的重要输入
    */
    Vec3 _velBody;

    // ==================== 坐标变换矩阵 ====================
    
    /**
    * @brief 身体坐标系到世界坐标系的旋转矩阵 (3x3旋转矩阵)
    * 
    * 将向量从身体坐标系转换到世界坐标系：
    * - 身体坐标系：以机器人身体为原点的坐标系
    * - 世界坐标系：固定的全局坐标系
    * - 用于力和位置的坐标系转换
    */
    RotMat _B2G_RotMat;
    
    /**
    * @brief 世界坐标系到身体坐标系的旋转矩阵 (3x3旋转矩阵)
    * 
    * 将向量从世界坐标系转换到身体坐标系：
    * - 是_B2G_RotMat的转置矩阵
    * - 用于将全局信息转换到机器人本地坐标系
    * - 简化某些控制算法的计算
    */
    RotMat _G2B_RotMat;

    // ==================== 足端状态变量 ====================
    
    /**
    * @brief 足端相对身体的位置 (3x4矩阵，每列代表一只脚)
    * 
    * 四个足端在身体坐标系中的位置：
    * - 每列[x, y, z]^T表示一个足端的三维坐标
    * - 列顺序：[前左, 前右, 后左, 后右]
    * - 用于运动学计算和控制
    */
    Vec34 _posFeet2BGlobal;
    
    /**
    * @brief 足端在世界坐标系中的初始位置 (3x4矩阵)
    * 
    * 记录进入步态测试状态时四个足端的位置：
    * - 用作轨迹规划的参考点
    * - 帮助定义足端的运动范围
    * - 用于计算相对位移
    */
    Vec34 _posFeetGlobalInit;
    
    /**
    * @brief 足端在世界坐标系中的目标位置 (3x4矩阵)
    * 
    * 步态规划器计算的足端期望位置：
    * - 摆动腿的轨迹跟踪目标
    * - 支撑腿的位置保持目标
    * - 是位置控制器的设定值
    */
    Vec34 _posFeetGlobalGoal;
    
    /**
    * @brief 足端在世界坐标系中的目标速度 (3x4矩阵)
    * 
    * 足端期望运动速度：
    * - 用于前馈控制，提高轨迹跟踪精度
    * - 摆动相中用于平滑轨迹生成
    * - 支撑相中通常为零（保持位置）
    */
    Vec34 _velFeetGlobalGoal;
    
    /**
    * @brief 足端在世界坐标系中的当前位置 (3x4矩阵)
    * 
    * 通过正运动学计算的足端实际位置：
    * - 基于当前关节角度计算得出
    * - 用于位置控制的反馈信号
    * - 与目标位置比较计算位置误差
    */
    Vec34 _posFeetGlobal;
    
    /**
    * @brief 足端在世界坐标系中的当前速度 (3x4矩阵)
    * 
    * 足端的实际运动速度：
    * - 通过微分或雅可比矩阵计算
    * - 用于速度控制和阻尼控制
    * - 提供动态响应的反馈信息
    */
    Vec34 _velFeetGlobal;
    
    /**
    * @brief 足端在世界坐标系中的作用力 (3x4矩阵)
    * 
    * 每个足端施加给地面的力：
    * - 支撑相：承担身体重量和控制力
    * - 摆动相：通常为零（不接触地面）
    * - 用于力控制和接触检测
    */
    Vec34 _forceFeetGlobal;
    
    /**
    * @brief 足端在身体坐标系中的作用力 (3x4矩阵)
    * 
    * 足端力在机器人身体坐标系中的表示：
    * - 通过坐标变换从世界坐标系转换而来
    * - 便于进行力矩平衡计算
    * - 用于关节力矩的映射计算
    */
    Vec34 _forceFeetBody;
};

#endif  // STEPTEST_H

/*
* ==================== State_StepTest 设计分析 ====================
* 
* ## 🎯 核心功能定位
* 
* State_StepTest是一个专门的测试状态，主要用于：
* 
* ### 1. 步态基础测试 🦵
* - **单足抬升测试**：验证单条腿的抬起和落下动作
* - **多足协调测试**：检查多条腿的协调运动能力
* - **步态周期验证**：测试步态时序的准确性
* - **接触状态切换**：验证支撑相和摆动相的平滑切换
* 
* ### 2. 控制系统验证 🔧
* - **平衡控制测试**：在步态过程中的姿态保持能力
* - **力控制精度**：支撑腿力控制的准确性测试
* - **位置控制精度**：摆动腿轨迹跟踪的精确度验证
* - **参数敏感性分析**：不同控制参数对性能的影响
* 
* ### 3. 系统安全验证 🛡️
* - **边界条件测试**：极限姿态和位置下的系统响应
* - **扰动抑制能力**：外部干扰下的恢复能力
* - **故障检测机制**：异常情况的检测和处理
* 
* ## 🏗️ 架构设计特点
* 
* ### 1. 完整的控制闭环
* ```cpp
* 状态估计 → 轨迹规划 → 控制算法 → 力矩输出
*     ↑                                    ↓
*     ← ← ← ← ← 反馈测量 ← ← ← ← ← ← ← ← ← ← ←
* ```
* 
* ### 2. 层次化的控制结构
* - **高层规划**：步态模式、接触序列
* - **中层控制**：平衡控制、轨迹生成
* - **低层执行**：关节力矩计算、执行器控制
* 
* ### 3. 模块化的组件设计
* - **独立的控制器**：位置控制器、力控制器
* - **可配置的参数**：增益矩阵、控制模式
* - **标准的接口**：与其他状态保持一致的接口
* 
* ## 🔧 控制算法核心
* 
* ### 1. 混合位置/力控制
* ```cpp
* // 支撑腿：主要进行力控制
* if (contact[i] == 1) {
*     // 通过期望的支撑力计算关节力矩
*     tau = J^T * F_desired
* }
* 
* // 摆动腿：主要进行位置控制  
* else {
*     // 通过位置误差计算关节力矩
*     tau = J^T * (Kp * pos_error + Kd * vel_error)
* }
* ```
* 
* ### 2. 全身平衡控制
* ```cpp
* // 计算期望的身体动态
* ddPcd = Kpp * pos_error + Kdp * vel_error
* dWbd = Kpw * att_error + Kdw * angvel_error
* 
* // 将身体控制力分配到各支撑腿
* F_feet = distribute(ddPcd, dWbd)
* ```
* 
* ### 3. 坐标系转换
* ```cpp
* // 世界坐标系 ↔ 身体坐标系
* force_body = _G2B_RotMat * force_global
* force_global = _B2G_RotMat * force_body
* ```
* 
* ## 📊 状态变量管理
* 
* ### 1. 实时状态更新
* - **传感器融合**：IMU + 编码器 + 接触传感器
* - **状态估计**：位置、速度、姿态的最优估计
* - **预测控制**：基于模型的前瞻性控制
* 
* ### 2. 多坐标系管理
* - **世界坐标系**：全局定位和导航
* - **身体坐标系**：机器人本体运动
* - **关节坐标系**：驱动器级别的控制
* 
* ### 3. 时序同步机制
* - **500Hz高频控制**：保证实时性要求
* - **步态相位同步**：协调四条腿的运动时序
* - **控制模式切换**：支撑相和摆动相的平滑过渡
* 
* ## 🔬 测试验证流程
* 
* ### 1. 参数调试阶段
* - 调整控制增益矩阵（Kp, Kd）
* - 优化步态高度和时序参数
* - 验证力控制和位置控制的切换
* 
* ### 2. 性能评估阶段  
* - 测量足端轨迹跟踪精度
* - 评估身体姿态稳定性
* - 分析能量消耗效率
* 
* ### 3. 鲁棒性测试阶段
* - 不同地形条件下的适应性
* - 外部扰动的抑制能力
* - 参数变化时的系统稳定性
* 
* ## 🚀 扩展应用价值
* 
* ### 1. 算法验证平台
* - 新控制算法的快速验证
* - 参数优化的实验平台
* - 理论模型的实际验证
* 
* ### 2. 教学演示工具
* - 步态原理的直观展示
* - 控制理论的实践应用
* - 机器人学的教学案例
* 
* ### 3. 产品开发基础
* - 为复杂步态开发提供基础
* - 系统集成的测试平台
* - 性能基准的建立标准
* 
* 这个状态类体现了现代机器人控制系统的精髓：
* 模块化设计、层次化控制、实时性保证和鲁棒性考虑！
*/