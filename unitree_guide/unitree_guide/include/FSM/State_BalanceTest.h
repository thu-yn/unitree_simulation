/**********************************************************************
Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/**
* @file State_BalanceTest.h
* @brief 平衡测试状态类头文件
* 
* 【文件作用】
* 本文件定义了四足机器人的平衡测试状态类，用于测试机器人的平衡控制算法。
* 在该状态下，机器人保持站立姿态，同时可以响应用户的姿态调整命令，
* 测试平衡控制器在不同姿态下的稳定性和响应性能。
* 
* 【主要功能】
* 1. 实现静态平衡控制 - 机器人四足着地，保持身体稳定
* 2. 支持实时姿态调整 - 响应用户输入，调整机器人的俯仰、横滚、偏航角度
* 3. 支持位置控制 - 可调整机器人身体在XYZ方向的位置
* 4. 平衡算法验证 - 为开发和调试平衡控制算法提供测试平台
* 
* 【适用场景】
* - 平衡控制器参数调优
* - 姿态控制算法测试
* - 机器人稳定性评估
* - 控制系统性能验证
*/

#ifndef BALANCETEST_H
#define BALANCETEST_H

#include "FSM/FSMState.h"

/**
* @class State_BalanceTest
* @brief 平衡测试状态类
* 
* 该类继承自FSMState基类，实现了平衡测试功能。
* 在此状态下，机器人将：
* 1. 保持四足支撑站立姿态
* 2. 运行平衡控制算法，维持身体稳定
* 3. 响应用户的姿态和位置调整命令
* 4. 实时计算并输出关节力矩以维持平衡
* 
* @note 该状态主要用于算法测试和参数调优，不适合长时间运行
*/
class State_BalanceTest : public FSMState{
public:
    /**
    * @brief 构造函数
    * @param ctrlComp 控制组件指针，包含所有控制相关的数据结构和接口
    * 
    * 构造函数将初始化所有必要的指针和参数，为平衡测试做准备
    */
    State_BalanceTest(CtrlComponents *ctrlComp);
    
    /**
    * @brief 析构函数
    * 
    * 空实现，因为所有资源都由外部管理，无需特殊清理
    */
    ~State_BalanceTest(){}
    
    /**
    * @brief 状态进入函数
    * 
    * 当FSM从其他状态切换到BALANCETEST状态时被调用。
    * 主要功能：
    * 1. 初始化平衡控制参数
    * 2. 设置初始的期望姿态和位置
    * 3. 配置控制增益矩阵
    * 4. 重置相关状态变量
    * 5. 设置所有足端为支撑状态
    */
    void enter();
    
    /**
    * @brief 状态运行函数
    * 
    * 在BALANCETEST状态下，每个控制周期（500Hz，即每2ms）被调用一次。
    * 主要功能：
    * 1. 读取用户命令，更新期望的姿态和位置
    * 2. 获取机器人当前状态（位置、速度、姿态等）
    * 3. 运行平衡控制算法，计算所需的身体加速度和角加速度
    * 4. 调用calcTau()计算关节力矩
    * 5. 输出力矩命令到底层控制器
    */
    void run();
    
    /**
    * @brief 状态退出函数
    * 
    * 当从BALANCETEST状态切换到其他状态时被调用。
    * 主要功能：
    * 1. 清理状态相关的数据
    * 2. 重置控制参数
    * 3. 为下一个状态的进入做准备
    */
    void exit();
    
    /**
    * @brief 状态切换检查函数
    * @return FSMStateName 返回下一个状态的名称
    * 
    * 检查是否满足状态切换的条件。
    * 支持的状态切换：
    * - L2_B → FIXEDSTAND（返回固定站立状态）
    * - START → TROTTING（进入小跑运动状态）
    * - 其他用户命令 → 相应的测试状态
    */
    FSMStateName checkChange();

private:
    /**
    * @brief 计算关节力矩的核心函数
    * 
    * 该函数实现了从足端力到关节力矩的转换：
    * 1. 根据平衡控制器输出的期望足端力
    * 2. 通过雅可比矩阵转置，计算各关节所需的力矩
    * 3. 考虑重力补偿和动力学约束
    * 4. 输出最终的关节力矩命令
    * 
    * @note 这是平衡控制的核心计算，直接影响机器人的稳定性
    */
    void calcTau();

    // ==================== 控制组件指针 ====================
    
    /**
    * @brief 状态估计器指针
    * 用于获取机器人的实时状态信息，包括：
    * - 身体位置和速度
    * - 身体姿态和角速度
    * - 足端位置信息
    */
    Estimator *_est;
    
    /**
    * @brief 四足机器人模型指针
    * 提供机器人的运动学和动力学信息：
    * - 正运动学和逆运动学计算
    * - 雅可比矩阵计算
    * - 质心位置和惯性参数
    */
    QuadrupedRobot *_robModel;
    
    /**
    * @brief 平衡控制器指针
    * 负责计算维持平衡所需的足端力：
    * - 根据期望的身体状态和当前状态的差异
    * - 输出四个足端的期望接触力
    * - 考虑ZMP稳定性约束
    */
    BalanceCtrl *_balCtrl;

    // ==================== 接触状态 ====================
    
    /**
    * @brief 足端接触状态向量
    * 
    * 4维整数向量，表示四条腿的接触状态：
    * - VecInt4[0]: 右前腿 (FR) 接触状态
    * - VecInt4[1]: 右后腿 (RR) 接触状态  
    * - VecInt4[2]: 左前腿 (FL) 接触状态
    * - VecInt4[3]: 左后腿 (RL) 接触状态
    * 
    * 值定义：
    * - 1: 足端接触地面，可以产生支撑力
    * - 0: 足端离开地面，处于摆动状态
    * 
    * @note 在平衡测试中，通常所有足端都保持接触状态（全为1）
    */
    VecInt4 *_contact;

    // ==================== 期望状态参数 ====================
    
    /**
    * @brief 期望身体姿态旋转矩阵
    * 
    * 3x3旋转矩阵，表示机器人身体相对于世界坐标系的期望姿态。
    * 由用户输入的俯仰(pitch)、横滚(roll)、偏航(yaw)角度计算得出。
    */
    RotMat _Rd;
    
    /**
    * @brief 初始身体姿态旋转矩阵
    * 
    * 记录进入平衡测试状态时的初始姿态，作为姿态调整的参考基准。
    * 在enter()函数中设置，通常为机器人的标准站立姿态。
    */
    RotMat _RdInit;
    
    /**
    * @brief 期望身体质心位置
    * 
    * 3维向量，表示机器人身体质心在世界坐标系下的期望位置：
    * - Vec3[0]: X方向位置（前后方向）
    * - Vec3[1]: Y方向位置（左右方向）  
    * - Vec3[2]: Z方向位置（上下高度）
    */
    Vec3 _pcd;
    
    /**
    * @brief 初始身体质心位置
    * 
    * 记录进入状态时的初始质心位置，作为位置调整的参考基准。
    * 用户的位置调整命令将基于这个初始位置进行相对调整。
    */
    Vec3 _pcdInit;

    // ==================== 控制增益参数 ====================
    
    /**
    * @brief 身体角速度控制增益
    * 
    * 标量增益，用于控制身体绕各轴的角速度响应。
    * 较大的值可以提高姿态控制的响应速度，但可能导致振荡。
    */
    double _kpw;
    
    /**
    * @brief 身体位置比例控制增益矩阵
    * 
    * 3x3对角矩阵，分别控制X、Y、Z三个方向的位置响应：
    * - _Kpp(0,0): X方向位置增益
    * - _Kpp(1,1): Y方向位置增益
    * - _Kpp(2,2): Z方向位置增益（高度控制）
    */
    Mat3 _Kpp;
    
    /**
    * @brief 身体位置微分控制增益矩阵
    * 
    * 3x3对角矩阵，控制身体在各方向的速度阻尼：
    * - 与_Kpp配合形成PD控制器
    * - 提供适当的阻尼以防止振荡
    */
    Mat3 _Kdp;
    
    /**
    * @brief 身体角速度微分控制增益矩阵
    * 
    * 3x3对角矩阵，控制身体绕各轴的角加速度：
    * - 与角速度比例增益配合
    * - 提供姿态控制的稳定性
    */
    Mat3 _Kdw;

    // ==================== 期望加速度 ====================
    
    /**
    * @brief 期望身体质心加速度
    * 
    * 3维向量，表示为了达到期望位置和速度，
    * 机器人身体质心应具有的加速度。
    * 由位置控制器根据位置和速度误差计算得出。
    */
    Vec3 _ddPcd;
    
    /**
    * @brief 期望身体角加速度
    * 
    * 3维向量，表示为了达到期望姿态和角速度，
    * 机器人身体应具有的角加速度。
    * 由姿态控制器根据姿态和角速度误差计算得出。
    */
    Vec3 _dWbd;

    // ==================== 机器人状态变量 ====================
    
    /**
    * @brief 关节角度向量
    * 
    * 12维向量，包含所有关节的当前角度：
    * [FR_hip, FR_thigh, FR_calf, FL_hip, FL_thigh, FL_calf,
    *  RR_hip, RR_thigh, RR_calf, RL_hip, RL_thigh, RL_calf]
    */
    Vec12 _q;
    
    /**
    * @brief 关节力矩向量
    * 
    * 12维向量，包含计算得出的所有关节力矩命令。
    * 这是calcTau()函数的输出，将被发送到底层控制器。
    */
    Vec12 _tau;
    
    /**
    * @brief 身体位置向量
    * 
    * 3维向量，表示机器人身体质心在世界坐标系下的实际位置。
    * 从状态估计器获取，用于位置控制的反馈。
    */
    Vec3 _posBody;
    
    /**
    * @brief 身体速度向量
    * 
    * 3维向量，表示机器人身体质心在世界坐标系下的线速度。
    * 从状态估计器获取，用于位置控制的微分反馈。
    */
    Vec3 _velBody;

    // ==================== 坐标变换矩阵 ====================
    
    /**
    * @brief 身体到全局坐标变换矩阵
    * 
    * 3x3旋转矩阵，用于将身体坐标系下的向量转换到世界坐标系。
    * B2G表示"Body to Global"的缩写。
    */
    RotMat _B2G_RotMat;
    
    /**
    * @brief 全局到身体坐标变换矩阵
    * 
    * 3x3旋转矩阵，用于将世界坐标系下的向量转换到身体坐标系。
    * G2B表示"Global to Body"的缩写，是_B2G_RotMat的转置。
    */
    RotMat _G2B_RotMat;

    // ==================== 足端相关变量 ====================
    
    /**
    * @brief 足端相对于身体的位置（全局表示）
    * 
    * 3x4矩阵，每一列代表一个足端相对于身体中心的位置向量：
    * - 列0: 右前足 (FR)
    * - 列1: 右后足 (RR)  
    * - 列2: 左前足 (FL)
    * - 列3: 左后足 (RL)
    */
    Vec34 _posFeet2BGlobal;
    
    /**
    * @brief 足端力（全局坐标系）
    * 
    * 3x4矩阵，每一列代表一个足端在世界坐标系下的接触力：
    * - 包含X、Y、Z三个方向的分力
    * - 由平衡控制器计算得出
    * - 用于维持机器人的平衡和姿态
    */
    Vec34 _forceFeetGlobal;
    
    /**
    * @brief 足端力（身体坐标系）
    * 
    * 3x4矩阵，表示各足端在身体坐标系下的接触力。
    * 从_forceFeetGlobal通过坐标变换得到，用于关节力矩的计算。
    */
    Vec34 _forceFeetBody;

    // ==================== 用户输入限制 ====================
    
    /**
    * @brief X方向移动范围限制
    * 
    * 限制机器人身体在前后方向的移动范围：
    * - _xMax: X方向最大位移（向前）
    * - _xMin: X方向最小位移（向后）
    * 
    * @note 防止用户输入过大的位置命令导致机器人失稳
    */
    float _xMax, _xMin;
    
    /**
    * @brief Y方向移动范围限制
    * 
    * 限制机器人身体在左右方向的移动范围：
    * - _yMax: Y方向最大位移（向左）
    * - _yMin: Y方向最小位移（向右）
    */
    float _yMax, _yMin;
    
    /**
    * @brief Z方向移动范围限制
    * 
    * 限制机器人身体的高度调整范围：
    * - _zMax: 最大高度
    * - _zMin: 最小高度
    * 
    * @note Z方向控制需要特别注意，避免机器人蹲得太低或站得太高
    */
    float _zMax, _zMin;
    
    /**
    * @brief 偏航角范围限制
    * 
    * 限制机器人身体绕Z轴的旋转范围：
    * - _yawMax: 最大偏航角（弧度）
    * - _yawMin: 最小偏航角（弧度）
    * 
    * @note 偏航角控制用于测试机器人的转向平衡能力
    */
    float _yawMax, _yawMin;
};

#endif  // BALANCETEST_H