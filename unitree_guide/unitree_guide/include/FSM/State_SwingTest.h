/**********************************************************************
 Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
***********************************************************************/

/**
* @file State_SwingTest.h
* @brief 摆动测试状态类定义
* 
* ==================== 文件作用说明 ====================
* 
* 本文件定义了State_SwingTest类，这是四足机器人控制系统中的一个专用测试状态，
* 主要用于：
* 
* 🎯 **核心功能**：
* 1. **单腿摆动测试**：测试单条腿（通常是右前腿）的摆动运动性能
* 2. **轨迹跟踪验证**：验证足端能否准确跟踪指定的三维轨迹
* 3. **运动学验证**：测试逆运动学求解和关节控制的准确性
* 4. **控制算法调试**：为开发者提供一个隔离的环境来调试控制参数
* 
* 🔧 **技术特点**：
* - 结合位置控制和力矩控制的双重控制模式
* - 支持实时手柄输入控制足端位置
* - 内置安全边界限制，防止超出机械极限
* - 高精度的PD控制器实现平滑运动
* 
* 🎮 **用户交互**：
* - 左摇杆Y轴：控制足端前后位置（X方向）
* - 左摇杆X轴：控制足端左右位置（Y方向） 
* - 右摇杆Y轴：控制足端上下位置（Z方向）
* - 状态切换：L2+B返回被动状态，L2+A进入固定站立
* 
* 🚀 **应用场景**：
* - 新算法验证：测试新的控制算法在单腿上的效果
* - 硬件调试：检查机械结构和电机性能
* - 参数整定：调节PD控制器的增益参数
* - 教学演示：直观展示机器人腿部运动原理
* 
* ==================== 在整体系统中的位置 ====================
* 
* State_SwingTest是FSM（有限状态机）系统中的一个测试辅助状态：
* 
* 状态转换路径：
* PASSIVE → FIXEDSTAND ⟷ SWINGTEST
*                      ⟷ TROTTING
*                      ⟷ BALANCETEST
*                      ⟷ STEPTEST
* 
* 与其他状态的关系：
* - 继承自FSMState基类，遵循统一的状态接口规范
* - 可以从FIXEDSTAND状态直接切换而来
* - 主要用于开发和调试阶段，不是常规运行状态
* - 为更复杂的运动状态（如TROTTING）提供基础验证
* 
***********************************************************************/

#ifndef STATE_SWINGTEST_H
#define STATE_SWINGTEST_H

// ==================== 头文件包含 ====================
#include "FSM/FSMState.h"        // 状态基类，提供状态机接口
#include "Gait/GaitGenerator.h"  // 步态生成器，虽然此状态不使用步态，但保持接口一致性

/**
* @brief 摆动测试状态类
* 
* 这个类实现了一个专门用于测试单腿摆动运动的控制状态。它结合了
* 位置控制和力矩控制两种控制模式，为机器人足端提供精确的三维
* 运动控制能力。
* 
* ==================== 设计模式分析 ====================
* 
* 🏗️ **继承模式**：
* - 继承自FSMState抽象基类
* - 实现四个核心虚函数：enter(), run(), exit(), checkChange()
* - 遵循状态机的标准生命周期管理
* 
* 🎛️ **控制模式**：
* - 混合控制策略：位置控制 + 力矩控制
* - 实时响应：每个500Hz控制周期更新控制命令
* - 安全限制：内置边界检查防止危险运动
* 
* 🔄 **数据流设计**：
* 输入：手柄摇杆数值 → 逆归一化处理 → 目标位置
* 处理：逆运动学求解 + PD控制算法
* 输出：关节位置命令 + 关节力矩命令
*/
class State_SwingTest : public FSMState{
public:
    // ==================== 构造函数和析构函数 ====================
    
    /**
    * @brief 构造函数
    * @param ctrlComp 控制组件指针，提供对整个控制系统的访问
    * 
    * 构造函数的主要职责：
    * 1. 调用基类构造函数，建立状态标识和控制系统连接
    * 2. 初始化运动边界参数，确保足端运动在安全范围内
    * 3. 为后续的控制参数设置做准备
    * 
    * 注意：真正的状态初始化在enter()函数中进行，构造函数只负责
    * 基础设置和安全参数配置。
    */
    State_SwingTest(CtrlComponents *ctrlComp);
    
    /**
    * @brief 析构函数
    * 
    * 由于使用默认析构函数，说明：
    * 1. 该类不直接管理动态分配的内存
    * 2. 所有资源的生命周期由外部管理
    * 3. 符合FSM状态对象的设计原则（对象常驻内存）
    */
    ~State_SwingTest(){};

    // ==================== FSMState接口实现 ====================
    
    /**
    * @brief 进入状态时的初始化函数
    * 
    * 当状态机切换到摆动测试状态时调用，负责：
    * 1. **控制器配置**：
    *    - 为4条腿设置合适的控制增益（仿真和真实机器人不同）
    *    - 配置测试腿（通常是右前腿）为摆动模式
    *    - 其他3条腿设置为支撑模式
    * 
    * 2. **初始状态记录**：
    *    - 记录当前所有关节的位置作为初始位置
    *    - 计算并保存当前足端位置作为运动起始点
    *    - 建立运动坐标系基准
    * 
    * 3. **控制参数设置**：
    *    - 配置PD控制器的比例和微分增益
    *    - 设置力矩控制的安全限制
    *    - 初始化运动轨迹生成参数
    * 
    * 4. **系统状态配置**：
    *    - 设置全部腿为摆动状态（用于测试）
    *    - 清零速度和力矩命令，确保平滑启动
    */
    void enter();
    
    /**
    * @brief 状态主执行函数
    * 
    * 这是摆动测试状态的核心函数，每个500Hz控制周期调用一次。
    * 
    * 执行流程：
    * 1. **用户输入处理**：
    *    - 读取手柄的摇杆数值（userValue.lx, ly, ry）
    *    - 将[-1,1]范围的输入映射到实际的足端坐标
    *    - 应用安全边界限制，防止超出机械极限
    * 
    * 2. **目标位置计算**：
    *    - X轴（前后）：基于左摇杆Y轴，范围[_xMin, _xMax]
    *    - Y轴（左右）：基于左摇杆X轴，范围[_yMin, _yMax] 
    *    - Z轴（上下）：基于右摇杆Y轴，范围[_zMin, _zMax]
    * 
    * 3. **双重控制执行**：
    *    - 位置控制：通过逆运动学计算关节角度命令
    *    - 力矩控制：通过雅可比矩阵计算关节力矩命令
    *    - 两种控制模式并行运行，提供更好的跟踪性能
    * 
    * 4. **命令发送**：
    *    - 将计算得到的位置和力矩命令发送给底层控制器
    *    - 确保命令的连续性和平滑性
    */
    void run();
    
    /**
    * @brief 退出状态时的清理函数
    * 
    * 当状态机从摆动测试状态切换到其他状态时调用：
    * 1. **命令清零**：
    *    - 清空所有待发送的控制命令
    *    - 确保不会有残留命令影响下一个状态
    * 
    * 2. **状态重置**：
    *    - 重置内部变量到默认状态
    *    - 为下次进入该状态做准备
    * 
    * 3. **安全保证**：
    *    - 确保机器人处于安全的控制状态
    *    - 为状态切换提供平滑过渡
    */
    void exit();
    
    /**
    * @brief 状态转换检查函数
    * @return FSMStateName 下一个状态的名称
    * 
    * 检查是否需要切换到其他状态：
    * 1. **紧急退出**：L2+B键 → 切换到PASSIVE状态
    * 2. **正常切换**：L2+A键 → 切换到FIXEDSTAND状态  
    * 3. **保持当前**：其他情况 → 继续在SWINGTEST状态
    * 
    * 这种设计确保用户可以随时安全地退出测试状态。
    */
    FSMStateName checkChange();

private:
    // ==================== 私有控制函数 ====================
    
    /**
    * @brief 位置控制函数
    * 
    * 实现基于逆运动学的位置控制：
    * 1. **目标设定**：将计算得到的足端目标位置设置到足端轨迹中
    * 2. **逆运动学求解**：调用机器人模型的逆运动学函数，计算
    *    达到目标足端位置所需的关节角度
    * 3. **命令设置**：将计算得到的关节角度设置为位置控制命令
    * 
    * 优点：精确的位置跟踪，适合慢速精确运动
    * 特点：通过关节角度直接控制，响应迅速
    */
    void _positionCtrl();
    
    /**
    * @brief 力矩控制函数
    * 
    * 实现基于雅可比矩阵的力矩控制：
    * 1. **状态反馈**：
    *    - 获取当前足端的实际位置和速度
    *    - 计算位置误差和速度误差
    * 
    * 2. **PD控制律**：
    *    - 使用比例-微分控制计算所需的足端力
    *    - force = Kp * (目标位置 - 当前位置) + Kd * (0 - 当前速度)
    * 
    * 3. **力矩转换**：
    *    - 通过雅可比矩阵的转置将足端力转换为关节力矩
    *    - 关节力矩 = 雅可比转置 * 足端力
    * 
    * 4. **命令输出**：
    *    - 将计算得到的关节力矩设置为力矩控制命令
    * 
    * 优点：柔顺控制，能够处理接触和碰撞
    * 特点：基于力反馈，提供更自然的运动感
    */
    void _torqueCtrl();

    // ==================== 私有成员变量 ====================
    
    // ---------- 位置相关变量 ----------
    
    /**
    * @brief 初始足端位置矩阵
    * @details Vec34类型：3行4列矩阵，存储4条腿的3D足端位置
    * 
    * 用途：
    * - 记录进入状态时所有足端的初始位置
    * - 作为运动轨迹的起始基准点
    * - 用于计算相对运动和安全边界
    */
    Vec34 _initFeetPos;
    
    /**
    * @brief 当前足端位置矩阵
    * @details 存储当前时刻所有足端的目标位置
    * 
    * 用途：
    * - 实时更新的足端位置目标
    * - 用于逆运动学计算
    * - 作为轨迹生成的中间变量
    */
    Vec34 _feetPos;
    
    /**
    * @brief 测试腿的初始位置
    * @details Vec3类型：3D向量，存储测试腿（通常是右前腿）的初始位置
    * 
    * 用途：
    * - 作为测试腿运动的参考原点
    * - 用于计算相对运动量
    * - 边界检查的基准点
    */
    Vec3  _initPos;
    
    /**
    * @brief 测试腿的目标位置
    * @details 根据用户输入实时计算的足端目标位置
    * 
    * 用途：
    * - 存储经过边界限制的目标位置
    * - 作为位置控制和力矩控制的参考
    * - 用于轨迹规划和插值
    */
    Vec3  _posGoal;
    
    /**
    * @brief 关节目标位置向量
    * @details Vec12类型：12维向量，存储所有关节的目标角度
    * 
    * 用途：
    * - 逆运动学求解的结果
    * - 发送给底层控制器的位置命令
    * - 12个关节对应：4条腿 × 每条腿3个关节
    */
    Vec12 _targetPos;
    
    // ---------- 运动边界限制变量 ----------
    
    /**
    * @brief X轴运动范围限制
    * @details 
    * - _xMin: X轴最小值（通常为负，表示向后运动的极限）
    * - _xMax: X轴最大值（通常为正，表示向前运动的极限）
    * 
    * 安全考虑：
    * - 防止足端运动超出机械极限
    * - 避免与机身或其他腿发生碰撞
    * - 确保逆运动学解的存在性
    */
    float _xMin, _xMax;
    
    /**
    * @brief Y轴运动范围限制  
    * @details
    * - _yMin: Y轴最小值（向左运动的极限）
    * - _yMax: Y轴最大值（向右运动的极限）
    * 
    * 实际应用：
    * - 通常设置为对称范围，如 [-0.15, 0.15] 米
    * - 考虑机器人的稳定性和平衡要求
    */
    float _yMin, _yMax;
    
    /**
    * @brief Z轴运动范围限制
    * @details
    * - _zMin: Z轴最小值（向下运动的极限，相对于初始高度）
    * - _zMax: Z轴最大值（向上运动的极限）
    * 
    * 特殊考虑：
    * - Z轴通常向上为正，向下为负
    * - 需要考虑地面约束和腿部伸展极限
    * - 抬腿高度不能过高，以免影响平衡
    */
    float _zMin, _zMax;
    
    // ---------- 控制器参数变量 ----------
    
    /**
    * @brief 比例控制增益矩阵
    * @details Mat3类型：3×3对角矩阵，分别对应X、Y、Z三个方向的比例增益
    * 
    * 作用：
    * - 决定位置误差对控制力的影响程度
    * - 较大的Kp值提供更强的位置纠正能力
    * - 但过大可能导致振荡和不稳定
    * 
    * 典型数值（从代码分析）：
    * - Kp_x = 20 N/m（X方向）
    * - Kp_y = 20 N/m（Y方向）  
    * - Kp_z = 50 N/m（Z方向，通常更高以对抗重力）
    */
    Mat3 _Kp;
    
    /**
    * @brief 微分控制增益矩阵
    * @details 对应速度误差的控制增益，提供阻尼作用
    * 
    * 作用：
    * - 抑制系统振荡，提高稳定性
    * - 减少超调，使运动更平滑
    * - 提供速度阻尼，模拟摩擦效果
    * 
    * 典型数值：
    * - Kd_x = 5 N·s/m（X方向）
    * - Kd_y = 5 N·s/m（Y方向）
    * - Kd_z = 20 N·s/m（Z方向）
    * 
    * 设计原则：
    * - Kd通常比Kp小一个数量级
    * - Z方向的Kd相对较高，提供更好的高度控制
    */
    Mat3 _Kd;
    
    /*
    * ==================== 变量设计分析 ====================
    * 
    * 🎯 **数据组织原则**：
    * 1. **类型安全**：使用强类型的向量和矩阵类型
    * 2. **语义清晰**：变量名直观反映其物理意义
    * 3. **访问效率**：频繁使用的变量放在类的前面
    * 4. **内存对齐**：考虑CPU缓存行的优化
    * 
    * 🔄 **数据流向**：
    * 输入 → 边界限制变量 → 目标位置变量 → 控制器参数 → 输出命令
    * 
    * 🛡️ **安全设计**：
    * - 所有运动都有边界限制
    * - 控制参数经过调试验证
    * - 支持紧急停止和状态切换
    * 
    * 📊 **性能优化**：
    * - 避免在run()函数中进行动态内存分配
    * - 使用预分配的固定大小变量
    * - 计算结果可以复用，减少重复计算
    */
};

#endif  // STATE_SWINGTEST_H

/*
* ==================== 总结与展望 ====================
* 
* 🎓 **学习价值**：
* State_SwingTest.h展示了如何设计一个专用的机器人测试状态：
* 1. 清晰的接口设计：遵循FSM状态的标准接口
* 2. 安全的控制逻辑：内置边界检查和紧急退出
* 3. 高效的数据结构：优化的变量组织和访问模式
* 4. 模块化的控制策略：位置控制和力矩控制的有机结合
* 
* 🚀 **扩展可能**：
* 基于这个设计，可以轻松扩展出：
* - State_MultiLegSwingTest：多腿同时摆动测试
* - State_TrajectoryTest：复杂轨迹跟踪测试  
* - State_ImpedanceTest：阻抗控制测试
* - State_ForceTest：力控制专项测试
* 
* 🔧 **实用建议**：
* 对于机器人开发者：
* 1. 先在仿真中验证参数和算法
* 2. 逐步增加控制增益，观察系统响应
* 3. 始终保持安全边界，防止机械损坏
* 4. 记录测试数据，用于算法优化和故障分析
* 
* 这种测试状态的设计理念体现了工程中"分而治之"的思想，
* 通过隔离复杂系统中的单个功能进行专项测试，大大提高了
* 开发效率和系统可靠性！
*/